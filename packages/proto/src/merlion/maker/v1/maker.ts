// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "merlion/maker/v1/maker.proto" (package "merlion.maker.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
/**
 * BackingRiskParams represents an object of backing coin risk parameters.
 *
 * @generated from protobuf message merlion.maker.v1.BackingRiskParams
 */
export interface BackingRiskParams {
    /**
     * backing coin denom
     *
     * @generated from protobuf field: string backing_denom = 1;
     */
    backingDenom: string;
    /**
     * whether enabled
     *
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
    /**
     * maximum total backing amount
     *
     * @generated from protobuf field: string max_backing = 3;
     */
    maxBacking: string;
    /**
     * maximum mintable Mer amount
     *
     * @generated from protobuf field: string max_mer_mint = 4;
     */
    maxMerMint: string;
    /**
     * mint fee rate
     *
     * @generated from protobuf field: string mint_fee = 5;
     */
    mintFee: string;
    /**
     * burn fee rate
     *
     * @generated from protobuf field: string burn_fee = 6;
     */
    burnFee: string;
    /**
     * buyback fee rate
     *
     * @generated from protobuf field: string buyback_fee = 7;
     */
    buybackFee: string;
    /**
     * recollateralize fee rate
     *
     * @generated from protobuf field: string recollateralize_fee = 8;
     */
    recollateralizeFee: string;
}
/**
 * CollateralRiskParams represents an object of collateral risk parameters.
 *
 * @generated from protobuf message merlion.maker.v1.CollateralRiskParams
 */
export interface CollateralRiskParams {
    /**
     * collateral coin denom
     *
     * @generated from protobuf field: string collateral_denom = 1;
     */
    collateralDenom: string;
    /**
     * whether enabled
     *
     * @generated from protobuf field: bool enabled = 2;
     */
    enabled: boolean;
    /**
     * maximum total collateral amount
     *
     * @generated from protobuf field: string max_collateral = 3;
     */
    maxCollateral: string;
    /**
     * maximum total mintable Mer amount
     *
     * @generated from protobuf field: string max_mer_mint = 4;
     */
    maxMerMint: string;
    /**
     * ratio at which a position is defined as undercollateralized
     *
     * @generated from protobuf field: string liquidation_threshold = 5;
     */
    liquidationThreshold: string;
    /**
     * maximum ratio of maximum amount of currency that can be borrowed with a
     * specific collateral
     *
     * @generated from protobuf field: string loan_to_value = 6;
     */
    loanToValue: string;
    /**
     * basic ratio of maximum amount of currency that can be borrowed with a
     * specific collateral
     *
     * @generated from protobuf field: string basic_loan_to_value = 7;
     */
    basicLoanToValue: string;
    /**
     * catalytic ratio of burned Lion to minted stablecoins, to maximize the LTV
     * in [basic-LTV, LTV]
     *
     * @generated from protobuf field: string catalytic_lion_ratio = 8;
     */
    catalyticLionRatio: string;
    /**
     * liquidation fee rate, i.e., the discount a liquidator gets when buying
     * collateral flagged for a liquidation
     *
     * @generated from protobuf field: string liquidation_fee = 9;
     */
    liquidationFee: string;
    /**
     * mint fee rate, i.e., extra fee debt
     *
     * @generated from protobuf field: string mint_fee = 10;
     */
    mintFee: string;
    /**
     * annual interest fee rate (APR)
     *
     * @generated from protobuf field: string interest_fee = 11;
     */
    interestFee: string;
}
/**
 * RegisterBackingProposal is a gov Content type to register eligible
 * strong-backing asset with backing risk parameters.
 *
 * @generated from protobuf message merlion.maker.v1.RegisterBackingProposal
 */
export interface RegisterBackingProposal {
    /**
     * title of the proposal
     *
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * proposal description
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * backing risk params
     *
     * @generated from protobuf field: merlion.maker.v1.BackingRiskParams risk_params = 3;
     */
    riskParams?: BackingRiskParams;
}
/**
 * RegisterCollateralProposal is a gov Content type to register eligible
 * collateral with collateral risk parameters.
 *
 * @generated from protobuf message merlion.maker.v1.RegisterCollateralProposal
 */
export interface RegisterCollateralProposal {
    /**
     * title of the proposal
     *
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * proposal description
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * collateral risk params
     *
     * @generated from protobuf field: merlion.maker.v1.CollateralRiskParams risk_params = 3;
     */
    riskParams?: CollateralRiskParams;
}
/**
 * SetBackingRiskParamsProposal is a gov Content type to set backing coin risk
 * parameters.
 *
 * @generated from protobuf message merlion.maker.v1.SetBackingRiskParamsProposal
 */
export interface SetBackingRiskParamsProposal {
    /**
     * title of the proposal
     *
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * proposal description
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * backing risk params
     *
     * @generated from protobuf field: merlion.maker.v1.BackingRiskParams risk_params = 3;
     */
    riskParams?: BackingRiskParams;
}
/**
 * SetCollateralRiskParamsProposal is a gov Content type to set collateral risk
 * parameters.
 *
 * @generated from protobuf message merlion.maker.v1.SetCollateralRiskParamsProposal
 */
export interface SetCollateralRiskParamsProposal {
    /**
     * title of the proposal
     *
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * proposal description
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * collateral risk params
     *
     * @generated from protobuf field: merlion.maker.v1.CollateralRiskParams risk_params = 3;
     */
    riskParams?: CollateralRiskParams;
}
/**
 * @generated from protobuf message merlion.maker.v1.BatchBackingRiskParams
 */
export interface BatchBackingRiskParams {
    /**
     * batch of collateral risk params
     *
     * @generated from protobuf field: repeated merlion.maker.v1.BackingRiskParams risk_params = 1;
     */
    riskParams: BackingRiskParams[];
}
/**
 * BatchSetBackingRiskParamsProposal is a gov Content type to batch set backing
 * coin risk parameters.
 *
 * @generated from protobuf message merlion.maker.v1.BatchSetBackingRiskParamsProposal
 */
export interface BatchSetBackingRiskParamsProposal {
    /**
     * title of the proposal
     *
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * proposal description
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * batch of collateral risk params
     *
     * @generated from protobuf field: repeated merlion.maker.v1.BackingRiskParams risk_params = 3;
     */
    riskParams: BackingRiskParams[];
}
/**
 * @generated from protobuf message merlion.maker.v1.BatchCollateralRiskParams
 */
export interface BatchCollateralRiskParams {
    /**
     * batch of collateral risk params
     *
     * @generated from protobuf field: repeated merlion.maker.v1.CollateralRiskParams risk_params = 1;
     */
    riskParams: CollateralRiskParams[];
}
/**
 * BatchSetCollateralRiskParamsProposal is a gov Content type to batch set
 * collateral risk parameters.
 *
 * @generated from protobuf message merlion.maker.v1.BatchSetCollateralRiskParamsProposal
 */
export interface BatchSetCollateralRiskParamsProposal {
    /**
     * title of the proposal
     *
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * proposal description
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * batch of collateral risk params
     *
     * @generated from protobuf field: repeated merlion.maker.v1.CollateralRiskParams risk_params = 3;
     */
    riskParams: CollateralRiskParams[];
}
/**
 * @generated from protobuf message merlion.maker.v1.TotalBacking
 */
export interface TotalBacking {
    /**
     * total minted mer
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_minted = 1;
     */
    merMinted?: Coin;
    /**
     * total burned lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_burned = 2;
     */
    lionBurned?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.PoolBacking
 */
export interface PoolBacking {
    /**
     * total minted mer
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_minted = 1;
     */
    merMinted?: Coin;
    /**
     * total backing
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing = 2;
     */
    backing?: Coin;
    /**
     * total burned lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_burned = 3;
     */
    lionBurned?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.AccountBacking
 */
export interface AccountBacking {
}
/**
 * @generated from protobuf message merlion.maker.v1.TotalCollateral
 */
export interface TotalCollateral {
    /**
     * total existing mer debt, including minted by collateral, mint fee, last
     * interest
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_debt = 1;
     */
    merDebt?: Coin;
    /**
     * total minted merl by burning lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_by_lion = 2;
     */
    merByLion?: Coin;
    /**
     * total burned lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_burned = 3;
     */
    lionBurned?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.PoolCollateral
 */
export interface PoolCollateral {
    /**
     * total collateral
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin collateral = 1;
     */
    collateral?: Coin;
    /**
     * total existing mer debt, including minted by collateral, mint fee, last
     * interest
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_debt = 2;
     */
    merDebt?: Coin;
    /**
     * total minted merl by burning lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_by_lion = 3;
     */
    merByLion?: Coin;
    /**
     * total burned lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_burned = 4;
     */
    lionBurned?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.AccountCollateral
 */
export interface AccountCollateral {
    /**
     * account who owns collateral
     *
     * @generated from protobuf field: string account = 1;
     */
    account: string;
    /**
     * existing collateral
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin collateral = 2;
     */
    collateral?: Coin;
    /**
     * remaining mer debt, including minted by collateral, mint fee, last interest
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_debt = 3;
     */
    merDebt?: Coin;
    /**
     * minted mer by burning lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mer_by_lion = 4;
     */
    merByLion?: Coin;
    /**
     * total burned lion
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_burned = 5;
     */
    lionBurned?: Coin;
    /**
     * remaining interest debt after last settlement
     *
     * @generated from protobuf field: cosmos.base.v1beta1.Coin last_interest = 6;
     */
    lastInterest?: Coin;
    /**
     * the block of last settlement
     *
     * @generated from protobuf field: int64 last_settlement_block = 7;
     */
    lastSettlementBlock: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class BackingRiskParams$Type extends MessageType<BackingRiskParams> {
    constructor() {
        super("merlion.maker.v1.BackingRiskParams", [
            { no: 1, name: "backing_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "max_backing", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int" } },
            { no: 4, name: "max_mer_mint", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int" } },
            { no: 5, name: "mint_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 6, name: "burn_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 7, name: "buyback_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 8, name: "recollateralize_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<BackingRiskParams>): BackingRiskParams {
        const message = { backingDenom: "", enabled: false, maxBacking: "", maxMerMint: "", mintFee: "", burnFee: "", buybackFee: "", recollateralizeFee: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BackingRiskParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BackingRiskParams): BackingRiskParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string backing_denom */ 1:
                    message.backingDenom = reader.string();
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                case /* string max_backing */ 3:
                    message.maxBacking = reader.string();
                    break;
                case /* string max_mer_mint */ 4:
                    message.maxMerMint = reader.string();
                    break;
                case /* string mint_fee */ 5:
                    message.mintFee = reader.string();
                    break;
                case /* string burn_fee */ 6:
                    message.burnFee = reader.string();
                    break;
                case /* string buyback_fee */ 7:
                    message.buybackFee = reader.string();
                    break;
                case /* string recollateralize_fee */ 8:
                    message.recollateralizeFee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BackingRiskParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string backing_denom = 1; */
        if (message.backingDenom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.backingDenom);
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        /* string max_backing = 3; */
        if (message.maxBacking !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.maxBacking);
        /* string max_mer_mint = 4; */
        if (message.maxMerMint !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.maxMerMint);
        /* string mint_fee = 5; */
        if (message.mintFee !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.mintFee);
        /* string burn_fee = 6; */
        if (message.burnFee !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.burnFee);
        /* string buyback_fee = 7; */
        if (message.buybackFee !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.buybackFee);
        /* string recollateralize_fee = 8; */
        if (message.recollateralizeFee !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.recollateralizeFee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.BackingRiskParams
 */
export const BackingRiskParams = new BackingRiskParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CollateralRiskParams$Type extends MessageType<CollateralRiskParams> {
    constructor() {
        super("merlion.maker.v1.CollateralRiskParams", [
            { no: 1, name: "collateral_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "max_collateral", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int" } },
            { no: 4, name: "max_mer_mint", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int" } },
            { no: 5, name: "liquidation_threshold", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 6, name: "loan_to_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 7, name: "basic_loan_to_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 8, name: "catalytic_lion_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 9, name: "liquidation_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 10, name: "mint_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 11, name: "interest_fee", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<CollateralRiskParams>): CollateralRiskParams {
        const message = { collateralDenom: "", enabled: false, maxCollateral: "", maxMerMint: "", liquidationThreshold: "", loanToValue: "", basicLoanToValue: "", catalyticLionRatio: "", liquidationFee: "", mintFee: "", interestFee: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CollateralRiskParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CollateralRiskParams): CollateralRiskParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string collateral_denom */ 1:
                    message.collateralDenom = reader.string();
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                case /* string max_collateral */ 3:
                    message.maxCollateral = reader.string();
                    break;
                case /* string max_mer_mint */ 4:
                    message.maxMerMint = reader.string();
                    break;
                case /* string liquidation_threshold */ 5:
                    message.liquidationThreshold = reader.string();
                    break;
                case /* string loan_to_value */ 6:
                    message.loanToValue = reader.string();
                    break;
                case /* string basic_loan_to_value */ 7:
                    message.basicLoanToValue = reader.string();
                    break;
                case /* string catalytic_lion_ratio */ 8:
                    message.catalyticLionRatio = reader.string();
                    break;
                case /* string liquidation_fee */ 9:
                    message.liquidationFee = reader.string();
                    break;
                case /* string mint_fee */ 10:
                    message.mintFee = reader.string();
                    break;
                case /* string interest_fee */ 11:
                    message.interestFee = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CollateralRiskParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string collateral_denom = 1; */
        if (message.collateralDenom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.collateralDenom);
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        /* string max_collateral = 3; */
        if (message.maxCollateral !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.maxCollateral);
        /* string max_mer_mint = 4; */
        if (message.maxMerMint !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.maxMerMint);
        /* string liquidation_threshold = 5; */
        if (message.liquidationThreshold !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.liquidationThreshold);
        /* string loan_to_value = 6; */
        if (message.loanToValue !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.loanToValue);
        /* string basic_loan_to_value = 7; */
        if (message.basicLoanToValue !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.basicLoanToValue);
        /* string catalytic_lion_ratio = 8; */
        if (message.catalyticLionRatio !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.catalyticLionRatio);
        /* string liquidation_fee = 9; */
        if (message.liquidationFee !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.liquidationFee);
        /* string mint_fee = 10; */
        if (message.mintFee !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.mintFee);
        /* string interest_fee = 11; */
        if (message.interestFee !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.interestFee);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.CollateralRiskParams
 */
export const CollateralRiskParams = new CollateralRiskParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterBackingProposal$Type extends MessageType<RegisterBackingProposal> {
    constructor() {
        super("merlion.maker.v1.RegisterBackingProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "risk_params", kind: "message", T: () => BackingRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<RegisterBackingProposal>): RegisterBackingProposal {
        const message = { title: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterBackingProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterBackingProposal): RegisterBackingProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* merlion.maker.v1.BackingRiskParams risk_params */ 3:
                    message.riskParams = BackingRiskParams.internalBinaryRead(reader, reader.uint32(), options, message.riskParams);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterBackingProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* merlion.maker.v1.BackingRiskParams risk_params = 3; */
        if (message.riskParams)
            BackingRiskParams.internalBinaryWrite(message.riskParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.RegisterBackingProposal
 */
export const RegisterBackingProposal = new RegisterBackingProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterCollateralProposal$Type extends MessageType<RegisterCollateralProposal> {
    constructor() {
        super("merlion.maker.v1.RegisterCollateralProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "risk_params", kind: "message", T: () => CollateralRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<RegisterCollateralProposal>): RegisterCollateralProposal {
        const message = { title: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterCollateralProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterCollateralProposal): RegisterCollateralProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* merlion.maker.v1.CollateralRiskParams risk_params */ 3:
                    message.riskParams = CollateralRiskParams.internalBinaryRead(reader, reader.uint32(), options, message.riskParams);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterCollateralProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* merlion.maker.v1.CollateralRiskParams risk_params = 3; */
        if (message.riskParams)
            CollateralRiskParams.internalBinaryWrite(message.riskParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.RegisterCollateralProposal
 */
export const RegisterCollateralProposal = new RegisterCollateralProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetBackingRiskParamsProposal$Type extends MessageType<SetBackingRiskParamsProposal> {
    constructor() {
        super("merlion.maker.v1.SetBackingRiskParamsProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "risk_params", kind: "message", T: () => BackingRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<SetBackingRiskParamsProposal>): SetBackingRiskParamsProposal {
        const message = { title: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetBackingRiskParamsProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetBackingRiskParamsProposal): SetBackingRiskParamsProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* merlion.maker.v1.BackingRiskParams risk_params */ 3:
                    message.riskParams = BackingRiskParams.internalBinaryRead(reader, reader.uint32(), options, message.riskParams);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetBackingRiskParamsProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* merlion.maker.v1.BackingRiskParams risk_params = 3; */
        if (message.riskParams)
            BackingRiskParams.internalBinaryWrite(message.riskParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.SetBackingRiskParamsProposal
 */
export const SetBackingRiskParamsProposal = new SetBackingRiskParamsProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetCollateralRiskParamsProposal$Type extends MessageType<SetCollateralRiskParamsProposal> {
    constructor() {
        super("merlion.maker.v1.SetCollateralRiskParamsProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "risk_params", kind: "message", T: () => CollateralRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<SetCollateralRiskParamsProposal>): SetCollateralRiskParamsProposal {
        const message = { title: "", description: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetCollateralRiskParamsProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetCollateralRiskParamsProposal): SetCollateralRiskParamsProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* merlion.maker.v1.CollateralRiskParams risk_params */ 3:
                    message.riskParams = CollateralRiskParams.internalBinaryRead(reader, reader.uint32(), options, message.riskParams);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetCollateralRiskParamsProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* merlion.maker.v1.CollateralRiskParams risk_params = 3; */
        if (message.riskParams)
            CollateralRiskParams.internalBinaryWrite(message.riskParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.SetCollateralRiskParamsProposal
 */
export const SetCollateralRiskParamsProposal = new SetCollateralRiskParamsProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchBackingRiskParams$Type extends MessageType<BatchBackingRiskParams> {
    constructor() {
        super("merlion.maker.v1.BatchBackingRiskParams", [
            { no: 1, name: "risk_params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BackingRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<BatchBackingRiskParams>): BatchBackingRiskParams {
        const message = { riskParams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchBackingRiskParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchBackingRiskParams): BatchBackingRiskParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated merlion.maker.v1.BackingRiskParams risk_params */ 1:
                    message.riskParams.push(BackingRiskParams.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchBackingRiskParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated merlion.maker.v1.BackingRiskParams risk_params = 1; */
        for (let i = 0; i < message.riskParams.length; i++)
            BackingRiskParams.internalBinaryWrite(message.riskParams[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.BatchBackingRiskParams
 */
export const BatchBackingRiskParams = new BatchBackingRiskParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchSetBackingRiskParamsProposal$Type extends MessageType<BatchSetBackingRiskParamsProposal> {
    constructor() {
        super("merlion.maker.v1.BatchSetBackingRiskParamsProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "risk_params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BackingRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<BatchSetBackingRiskParamsProposal>): BatchSetBackingRiskParamsProposal {
        const message = { title: "", description: "", riskParams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchSetBackingRiskParamsProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchSetBackingRiskParamsProposal): BatchSetBackingRiskParamsProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated merlion.maker.v1.BackingRiskParams risk_params */ 3:
                    message.riskParams.push(BackingRiskParams.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchSetBackingRiskParamsProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated merlion.maker.v1.BackingRiskParams risk_params = 3; */
        for (let i = 0; i < message.riskParams.length; i++)
            BackingRiskParams.internalBinaryWrite(message.riskParams[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.BatchSetBackingRiskParamsProposal
 */
export const BatchSetBackingRiskParamsProposal = new BatchSetBackingRiskParamsProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchCollateralRiskParams$Type extends MessageType<BatchCollateralRiskParams> {
    constructor() {
        super("merlion.maker.v1.BatchCollateralRiskParams", [
            { no: 1, name: "risk_params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CollateralRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<BatchCollateralRiskParams>): BatchCollateralRiskParams {
        const message = { riskParams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchCollateralRiskParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchCollateralRiskParams): BatchCollateralRiskParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated merlion.maker.v1.CollateralRiskParams risk_params */ 1:
                    message.riskParams.push(CollateralRiskParams.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchCollateralRiskParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated merlion.maker.v1.CollateralRiskParams risk_params = 1; */
        for (let i = 0; i < message.riskParams.length; i++)
            CollateralRiskParams.internalBinaryWrite(message.riskParams[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.BatchCollateralRiskParams
 */
export const BatchCollateralRiskParams = new BatchCollateralRiskParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchSetCollateralRiskParamsProposal$Type extends MessageType<BatchSetCollateralRiskParamsProposal> {
    constructor() {
        super("merlion.maker.v1.BatchSetCollateralRiskParamsProposal", [
            { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "risk_params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CollateralRiskParams, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<BatchSetCollateralRiskParamsProposal>): BatchSetCollateralRiskParamsProposal {
        const message = { title: "", description: "", riskParams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchSetCollateralRiskParamsProposal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchSetCollateralRiskParamsProposal): BatchSetCollateralRiskParamsProposal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string title */ 1:
                    message.title = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* repeated merlion.maker.v1.CollateralRiskParams risk_params */ 3:
                    message.riskParams.push(CollateralRiskParams.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchSetCollateralRiskParamsProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string title = 1; */
        if (message.title !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.title);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* repeated merlion.maker.v1.CollateralRiskParams risk_params = 3; */
        for (let i = 0; i < message.riskParams.length; i++)
            CollateralRiskParams.internalBinaryWrite(message.riskParams[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.BatchSetCollateralRiskParamsProposal
 */
export const BatchSetCollateralRiskParamsProposal = new BatchSetCollateralRiskParamsProposal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TotalBacking$Type extends MessageType<TotalBacking> {
    constructor() {
        super("merlion.maker.v1.TotalBacking", [
            { no: 1, name: "mer_minted", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "lion_burned", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<TotalBacking>): TotalBacking {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TotalBacking>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TotalBacking): TotalBacking {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin mer_minted */ 1:
                    message.merMinted = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merMinted);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_burned */ 2:
                    message.lionBurned = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionBurned);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TotalBacking, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin mer_minted = 1; */
        if (message.merMinted)
            Coin.internalBinaryWrite(message.merMinted, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_burned = 2; */
        if (message.lionBurned)
            Coin.internalBinaryWrite(message.lionBurned, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.TotalBacking
 */
export const TotalBacking = new TotalBacking$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PoolBacking$Type extends MessageType<PoolBacking> {
    constructor() {
        super("merlion.maker.v1.PoolBacking", [
            { no: 1, name: "mer_minted", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "backing", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "lion_burned", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<PoolBacking>): PoolBacking {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PoolBacking>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PoolBacking): PoolBacking {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin mer_minted */ 1:
                    message.merMinted = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merMinted);
                    break;
                case /* cosmos.base.v1beta1.Coin backing */ 2:
                    message.backing = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backing);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_burned */ 3:
                    message.lionBurned = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionBurned);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PoolBacking, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin mer_minted = 1; */
        if (message.merMinted)
            Coin.internalBinaryWrite(message.merMinted, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin backing = 2; */
        if (message.backing)
            Coin.internalBinaryWrite(message.backing, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_burned = 3; */
        if (message.lionBurned)
            Coin.internalBinaryWrite(message.lionBurned, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.PoolBacking
 */
export const PoolBacking = new PoolBacking$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountBacking$Type extends MessageType<AccountBacking> {
    constructor() {
        super("merlion.maker.v1.AccountBacking", [], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<AccountBacking>): AccountBacking {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountBacking>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountBacking): AccountBacking {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AccountBacking, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.AccountBacking
 */
export const AccountBacking = new AccountBacking$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TotalCollateral$Type extends MessageType<TotalCollateral> {
    constructor() {
        super("merlion.maker.v1.TotalCollateral", [
            { no: 1, name: "mer_debt", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "mer_by_lion", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "lion_burned", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<TotalCollateral>): TotalCollateral {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TotalCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TotalCollateral): TotalCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin mer_debt */ 1:
                    message.merDebt = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merDebt);
                    break;
                case /* cosmos.base.v1beta1.Coin mer_by_lion */ 2:
                    message.merByLion = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merByLion);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_burned */ 3:
                    message.lionBurned = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionBurned);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TotalCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin mer_debt = 1; */
        if (message.merDebt)
            Coin.internalBinaryWrite(message.merDebt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mer_by_lion = 2; */
        if (message.merByLion)
            Coin.internalBinaryWrite(message.merByLion, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_burned = 3; */
        if (message.lionBurned)
            Coin.internalBinaryWrite(message.lionBurned, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.TotalCollateral
 */
export const TotalCollateral = new TotalCollateral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PoolCollateral$Type extends MessageType<PoolCollateral> {
    constructor() {
        super("merlion.maker.v1.PoolCollateral", [
            { no: 1, name: "collateral", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "mer_debt", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "mer_by_lion", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 4, name: "lion_burned", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<PoolCollateral>): PoolCollateral {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PoolCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PoolCollateral): PoolCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin collateral */ 1:
                    message.collateral = Coin.internalBinaryRead(reader, reader.uint32(), options, message.collateral);
                    break;
                case /* cosmos.base.v1beta1.Coin mer_debt */ 2:
                    message.merDebt = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merDebt);
                    break;
                case /* cosmos.base.v1beta1.Coin mer_by_lion */ 3:
                    message.merByLion = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merByLion);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_burned */ 4:
                    message.lionBurned = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionBurned);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PoolCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin collateral = 1; */
        if (message.collateral)
            Coin.internalBinaryWrite(message.collateral, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mer_debt = 2; */
        if (message.merDebt)
            Coin.internalBinaryWrite(message.merDebt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mer_by_lion = 3; */
        if (message.merByLion)
            Coin.internalBinaryWrite(message.merByLion, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_burned = 4; */
        if (message.lionBurned)
            Coin.internalBinaryWrite(message.lionBurned, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.PoolCollateral
 */
export const PoolCollateral = new PoolCollateral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountCollateral$Type extends MessageType<AccountCollateral> {
    constructor() {
        super("merlion.maker.v1.AccountCollateral", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "collateral", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "mer_debt", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 4, name: "mer_by_lion", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 5, name: "lion_burned", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 6, name: "last_interest", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 7, name: "last_settlement_block", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ], { "gogoproto.equal": false });
    }
    create(value?: PartialMessage<AccountCollateral>): AccountCollateral {
        const message = { account: "", lastSettlementBlock: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountCollateral): AccountCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin collateral */ 2:
                    message.collateral = Coin.internalBinaryRead(reader, reader.uint32(), options, message.collateral);
                    break;
                case /* cosmos.base.v1beta1.Coin mer_debt */ 3:
                    message.merDebt = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merDebt);
                    break;
                case /* cosmos.base.v1beta1.Coin mer_by_lion */ 4:
                    message.merByLion = Coin.internalBinaryRead(reader, reader.uint32(), options, message.merByLion);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_burned */ 5:
                    message.lionBurned = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionBurned);
                    break;
                case /* cosmos.base.v1beta1.Coin last_interest */ 6:
                    message.lastInterest = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lastInterest);
                    break;
                case /* int64 last_settlement_block */ 7:
                    message.lastSettlementBlock = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* cosmos.base.v1beta1.Coin collateral = 2; */
        if (message.collateral)
            Coin.internalBinaryWrite(message.collateral, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mer_debt = 3; */
        if (message.merDebt)
            Coin.internalBinaryWrite(message.merDebt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mer_by_lion = 4; */
        if (message.merByLion)
            Coin.internalBinaryWrite(message.merByLion, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_burned = 5; */
        if (message.lionBurned)
            Coin.internalBinaryWrite(message.lionBurned, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin last_interest = 6; */
        if (message.lastInterest)
            Coin.internalBinaryWrite(message.lastInterest, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int64 last_settlement_block = 7; */
        if (message.lastSettlementBlock !== "0")
            writer.tag(7, WireType.Varint).int64(message.lastSettlementBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.AccountCollateral
 */
export const AccountCollateral = new AccountCollateral$Type();
