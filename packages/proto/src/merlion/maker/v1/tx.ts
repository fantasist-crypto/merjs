// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "merlion/maker/v1/tx.proto" (package "merlion.maker.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
/**
 * MsgMintBySwap represents a message to mint Mer stablecoins by swapping.
 *
 * @generated from protobuf message merlion.maker.v1.MsgMintBySwap
 */
export interface MsgMintBySwap {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_out = 3;
     */
    mintOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in_max = 4;
     */
    backingInMax?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in_max = 5;
     */
    lionInMax?: Coin;
}
/**
 * MsgMintBySwapResponse defines the Msg/MintBySwap response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgMintBySwapResponse
 */
export interface MsgMintBySwapResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_fee = 1;
     */
    mintFee?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in = 2;
     */
    backingIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in = 3;
     */
    lionIn?: Coin;
}
/**
 * MsgBurnBySwap represents a message to burn Mer stablecoins by swapping.
 *
 * @generated from protobuf message merlion.maker.v1.MsgBurnBySwap
 */
export interface MsgBurnBySwap {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin burn_in = 3;
     */
    burnIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out_min = 4;
     */
    backingOutMin?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out_min = 5;
     */
    lionOutMin?: Coin;
}
/**
 * MsgBurnBySwapResponse defines the Msg/BurnBySwap response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgBurnBySwapResponse
 */
export interface MsgBurnBySwapResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin burn_fee = 2;
     */
    burnFee?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out = 3;
     */
    backingOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out = 4;
     */
    lionOut?: Coin;
}
/**
 * MsgBuyBacking represents a message to buy strong-backing assets.
 *
 * @generated from protobuf message merlion.maker.v1.MsgBuyBacking
 */
export interface MsgBuyBacking {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in = 3;
     */
    lionIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out_min = 4;
     */
    backingOutMin?: Coin;
}
/**
 * MsgBuyBackingResponse defines the Msg/BuyBacking response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgBuyBackingResponse
 */
export interface MsgBuyBackingResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out = 4;
     */
    backingOut?: Coin;
}
/**
 * MsgSellBacking represents a message to sell strong-backing
 * assets.
 *
 * @generated from protobuf message merlion.maker.v1.MsgSellBacking
 */
export interface MsgSellBacking {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in = 3;
     */
    backingIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out_min = 4;
     */
    lionOutMin?: Coin;
}
/**
 * MsgSellBackingResponse defines the Msg/SellBacking response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgSellBackingResponse
 */
export interface MsgSellBackingResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out = 4;
     */
    lionOut?: Coin;
}
/**
 * MsgMintByCollateral represents a message to mint Mer stablecoins by locking
 * collateral.
 *
 * @generated from protobuf message merlion.maker.v1.MsgMintByCollateral
 */
export interface MsgMintByCollateral {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: string collateral_denom = 3;
     */
    collateralDenom: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_out = 4;
     */
    mintOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in_max = 5;
     */
    lionInMax?: Coin;
}
/**
 * MsgMintByCollateralResponse defines the Msg/MintByCollateral response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgMintByCollateralResponse
 */
export interface MsgMintByCollateralResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_fee = 1;
     */
    mintFee?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in = 2;
     */
    lionIn?: Coin;
}
/**
 * MsgBurnByCollateral represents a message to burn Mer stablecoins by unlocking
 * collateral.
 *
 * @generated from protobuf message merlion.maker.v1.MsgBurnByCollateral
 */
export interface MsgBurnByCollateral {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string collateral_denom = 2;
     */
    collateralDenom: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin repay_in_max = 3;
     */
    repayInMax?: Coin;
}
/**
 * MsgBurnByCollateralResponse defines the Msg/BurnByCollateral response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgBurnByCollateralResponse
 */
export interface MsgBurnByCollateralResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin repay_in = 1;
     */
    repayIn?: Coin;
}
/**
 * MsgDepositCollateral represents a message to deposit collateral assets.
 *
 * @generated from protobuf message merlion.maker.v1.MsgDepositCollateral
 */
export interface MsgDepositCollateral {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin collateral = 3;
     */
    collateral?: Coin;
}
/**
 * MsgDepositCollateralResponse defines the Msg/DepositCollateral response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgDepositCollateralResponse
 */
export interface MsgDepositCollateralResponse {
}
/**
 * MsgRedeemCollateral represents a message to redeem collateral assets.
 *
 * @generated from protobuf message merlion.maker.v1.MsgRedeemCollateral
 */
export interface MsgRedeemCollateral {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin collateral = 3;
     */
    collateral?: Coin;
}
/**
 * MsgRedeemCollateralResponse defines the Msg/RedeemCollateral response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgRedeemCollateralResponse
 */
export interface MsgRedeemCollateralResponse {
}
/**
 * MsgLiquidateCollateral represents a message to liquidates collateral assets.
 *
 * @generated from protobuf message merlion.maker.v1.MsgLiquidateCollateral
 */
export interface MsgLiquidateCollateral {
    /**
     * @generated from protobuf field: string sender = 1;
     */
    sender: string;
    /**
     * @generated from protobuf field: string to = 2;
     */
    to: string;
    /**
     * @generated from protobuf field: string debtor = 3;
     */
    debtor: string;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin collateral = 4;
     */
    collateral?: Coin;
}
/**
 * MsgReCollateralizeResponse defines the Msg/LiquidateCollateral response type.
 *
 * @generated from protobuf message merlion.maker.v1.MsgLiquidateCollateralResponse
 */
export interface MsgLiquidateCollateralResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin repay_in = 1;
     */
    repayIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin collateral_out = 2;
     */
    collateralOut?: Coin;
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgMintBySwap$Type extends MessageType<MsgMintBySwap> {
    constructor() {
        super("merlion.maker.v1.MsgMintBySwap", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "mint_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"mint_out\"" } },
            { no: 4, name: "backing_in_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"backing_in_max\"" } },
            { no: 5, name: "lion_in_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_in_max\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgMintBySwap>): MsgMintBySwap {
        const message = { sender: "", to: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgMintBySwap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMintBySwap): MsgMintBySwap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin mint_out */ 3:
                    message.mintOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintOut);
                    break;
                case /* cosmos.base.v1beta1.Coin backing_in_max */ 4:
                    message.backingInMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingInMax);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in_max */ 5:
                    message.lionInMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionInMax);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMintBySwap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* cosmos.base.v1beta1.Coin mint_out = 3; */
        if (message.mintOut)
            Coin.internalBinaryWrite(message.mintOut, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin backing_in_max = 4; */
        if (message.backingInMax)
            Coin.internalBinaryWrite(message.backingInMax, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_in_max = 5; */
        if (message.lionInMax)
            Coin.internalBinaryWrite(message.lionInMax, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgMintBySwap
 */
export const MsgMintBySwap = new MsgMintBySwap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgMintBySwapResponse$Type extends MessageType<MsgMintBySwapResponse> {
    constructor() {
        super("merlion.maker.v1.MsgMintBySwapResponse", [
            { no: 1, name: "mint_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"mint_fee\"" } },
            { no: 2, name: "backing_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"backing_in\"" } },
            { no: 3, name: "lion_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_in\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgMintBySwapResponse>): MsgMintBySwapResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgMintBySwapResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMintBySwapResponse): MsgMintBySwapResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin mint_fee */ 1:
                    message.mintFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintFee);
                    break;
                case /* cosmos.base.v1beta1.Coin backing_in */ 2:
                    message.backingIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingIn);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in */ 3:
                    message.lionIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionIn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMintBySwapResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin mint_fee = 1; */
        if (message.mintFee)
            Coin.internalBinaryWrite(message.mintFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin backing_in = 2; */
        if (message.backingIn)
            Coin.internalBinaryWrite(message.backingIn, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_in = 3; */
        if (message.lionIn)
            Coin.internalBinaryWrite(message.lionIn, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgMintBySwapResponse
 */
export const MsgMintBySwapResponse = new MsgMintBySwapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBurnBySwap$Type extends MessageType<MsgBurnBySwap> {
    constructor() {
        super("merlion.maker.v1.MsgBurnBySwap", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "burn_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"burn_in\"" } },
            { no: 4, name: "backing_out_min", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"backing_out_min\"" } },
            { no: 5, name: "lion_out_min", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_out_min\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBurnBySwap>): MsgBurnBySwap {
        const message = { sender: "", to: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgBurnBySwap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBurnBySwap): MsgBurnBySwap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin burn_in */ 3:
                    message.burnIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.burnIn);
                    break;
                case /* cosmos.base.v1beta1.Coin backing_out_min */ 4:
                    message.backingOutMin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOutMin);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_out_min */ 5:
                    message.lionOutMin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOutMin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBurnBySwap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* cosmos.base.v1beta1.Coin burn_in = 3; */
        if (message.burnIn)
            Coin.internalBinaryWrite(message.burnIn, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin backing_out_min = 4; */
        if (message.backingOutMin)
            Coin.internalBinaryWrite(message.backingOutMin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_out_min = 5; */
        if (message.lionOutMin)
            Coin.internalBinaryWrite(message.lionOutMin, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgBurnBySwap
 */
export const MsgBurnBySwap = new MsgBurnBySwap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBurnBySwapResponse$Type extends MessageType<MsgBurnBySwapResponse> {
    constructor() {
        super("merlion.maker.v1.MsgBurnBySwapResponse", [
            { no: 2, name: "burn_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"burn_fee\"" } },
            { no: 3, name: "backing_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"backing_out\"" } },
            { no: 4, name: "lion_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_out\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgBurnBySwapResponse>): MsgBurnBySwapResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgBurnBySwapResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBurnBySwapResponse): MsgBurnBySwapResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin burn_fee */ 2:
                    message.burnFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.burnFee);
                    break;
                case /* cosmos.base.v1beta1.Coin backing_out */ 3:
                    message.backingOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOut);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_out */ 4:
                    message.lionOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOut);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBurnBySwapResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin burn_fee = 2; */
        if (message.burnFee)
            Coin.internalBinaryWrite(message.burnFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin backing_out = 3; */
        if (message.backingOut)
            Coin.internalBinaryWrite(message.backingOut, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_out = 4; */
        if (message.lionOut)
            Coin.internalBinaryWrite(message.lionOut, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgBurnBySwapResponse
 */
export const MsgBurnBySwapResponse = new MsgBurnBySwapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBuyBacking$Type extends MessageType<MsgBuyBacking> {
    constructor() {
        super("merlion.maker.v1.MsgBuyBacking", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "lion_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_in\"" } },
            { no: 4, name: "backing_out_min", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"backing_out_min\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBuyBacking>): MsgBuyBacking {
        const message = { sender: "", to: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgBuyBacking>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBuyBacking): MsgBuyBacking {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in */ 3:
                    message.lionIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionIn);
                    break;
                case /* cosmos.base.v1beta1.Coin backing_out_min */ 4:
                    message.backingOutMin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOutMin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBuyBacking, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* cosmos.base.v1beta1.Coin lion_in = 3; */
        if (message.lionIn)
            Coin.internalBinaryWrite(message.lionIn, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin backing_out_min = 4; */
        if (message.backingOutMin)
            Coin.internalBinaryWrite(message.backingOutMin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgBuyBacking
 */
export const MsgBuyBacking = new MsgBuyBacking$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBuyBackingResponse$Type extends MessageType<MsgBuyBackingResponse> {
    constructor() {
        super("merlion.maker.v1.MsgBuyBackingResponse", [
            { no: 4, name: "backing_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"backing_out\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgBuyBackingResponse>): MsgBuyBackingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgBuyBackingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBuyBackingResponse): MsgBuyBackingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_out */ 4:
                    message.backingOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOut);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBuyBackingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_out = 4; */
        if (message.backingOut)
            Coin.internalBinaryWrite(message.backingOut, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgBuyBackingResponse
 */
export const MsgBuyBackingResponse = new MsgBuyBackingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSellBacking$Type extends MessageType<MsgSellBacking> {
    constructor() {
        super("merlion.maker.v1.MsgSellBacking", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "backing_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"backing_in\"" } },
            { no: 4, name: "lion_out_min", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_out_min\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgSellBacking>): MsgSellBacking {
        const message = { sender: "", to: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSellBacking>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSellBacking): MsgSellBacking {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin backing_in */ 3:
                    message.backingIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingIn);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_out_min */ 4:
                    message.lionOutMin = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOutMin);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSellBacking, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* cosmos.base.v1beta1.Coin backing_in = 3; */
        if (message.backingIn)
            Coin.internalBinaryWrite(message.backingIn, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_out_min = 4; */
        if (message.lionOutMin)
            Coin.internalBinaryWrite(message.lionOutMin, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgSellBacking
 */
export const MsgSellBacking = new MsgSellBacking$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgSellBackingResponse$Type extends MessageType<MsgSellBackingResponse> {
    constructor() {
        super("merlion.maker.v1.MsgSellBackingResponse", [
            { no: 4, name: "lion_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_out\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgSellBackingResponse>): MsgSellBackingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgSellBackingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgSellBackingResponse): MsgSellBackingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin lion_out */ 4:
                    message.lionOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOut);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgSellBackingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin lion_out = 4; */
        if (message.lionOut)
            Coin.internalBinaryWrite(message.lionOut, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgSellBackingResponse
 */
export const MsgSellBackingResponse = new MsgSellBackingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgMintByCollateral$Type extends MessageType<MsgMintByCollateral> {
    constructor() {
        super("merlion.maker.v1.MsgMintByCollateral", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "collateral_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"collateral_denom\"" } },
            { no: 4, name: "mint_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"mint_out\"" } },
            { no: 5, name: "lion_in_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_in_max\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgMintByCollateral>): MsgMintByCollateral {
        const message = { sender: "", to: "", collateralDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgMintByCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMintByCollateral): MsgMintByCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* string collateral_denom */ 3:
                    message.collateralDenom = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin mint_out */ 4:
                    message.mintOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintOut);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in_max */ 5:
                    message.lionInMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionInMax);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMintByCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* string collateral_denom = 3; */
        if (message.collateralDenom !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.collateralDenom);
        /* cosmos.base.v1beta1.Coin mint_out = 4; */
        if (message.mintOut)
            Coin.internalBinaryWrite(message.mintOut, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_in_max = 5; */
        if (message.lionInMax)
            Coin.internalBinaryWrite(message.lionInMax, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgMintByCollateral
 */
export const MsgMintByCollateral = new MsgMintByCollateral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgMintByCollateralResponse$Type extends MessageType<MsgMintByCollateralResponse> {
    constructor() {
        super("merlion.maker.v1.MsgMintByCollateralResponse", [
            { no: 1, name: "mint_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"mint_fee\"" } },
            { no: 2, name: "lion_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"lion_in\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgMintByCollateralResponse>): MsgMintByCollateralResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgMintByCollateralResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgMintByCollateralResponse): MsgMintByCollateralResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin mint_fee */ 1:
                    message.mintFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintFee);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in */ 2:
                    message.lionIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionIn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgMintByCollateralResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin mint_fee = 1; */
        if (message.mintFee)
            Coin.internalBinaryWrite(message.mintFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_in = 2; */
        if (message.lionIn)
            Coin.internalBinaryWrite(message.lionIn, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgMintByCollateralResponse
 */
export const MsgMintByCollateralResponse = new MsgMintByCollateralResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBurnByCollateral$Type extends MessageType<MsgBurnByCollateral> {
    constructor() {
        super("merlion.maker.v1.MsgBurnByCollateral", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "collateral_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"collateral_denom\"" } },
            { no: 3, name: "repay_in_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"repay_in_max\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgBurnByCollateral>): MsgBurnByCollateral {
        const message = { sender: "", collateralDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgBurnByCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBurnByCollateral): MsgBurnByCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string collateral_denom */ 2:
                    message.collateralDenom = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin repay_in_max */ 3:
                    message.repayInMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.repayInMax);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBurnByCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string collateral_denom = 2; */
        if (message.collateralDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.collateralDenom);
        /* cosmos.base.v1beta1.Coin repay_in_max = 3; */
        if (message.repayInMax)
            Coin.internalBinaryWrite(message.repayInMax, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgBurnByCollateral
 */
export const MsgBurnByCollateral = new MsgBurnByCollateral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgBurnByCollateralResponse$Type extends MessageType<MsgBurnByCollateralResponse> {
    constructor() {
        super("merlion.maker.v1.MsgBurnByCollateralResponse", [
            { no: 1, name: "repay_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"repay_in\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgBurnByCollateralResponse>): MsgBurnByCollateralResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgBurnByCollateralResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgBurnByCollateralResponse): MsgBurnByCollateralResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin repay_in */ 1:
                    message.repayIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.repayIn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgBurnByCollateralResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin repay_in = 1; */
        if (message.repayIn)
            Coin.internalBinaryWrite(message.repayIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgBurnByCollateralResponse
 */
export const MsgBurnByCollateralResponse = new MsgBurnByCollateralResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositCollateral$Type extends MessageType<MsgDepositCollateral> {
    constructor() {
        super("merlion.maker.v1.MsgDepositCollateral", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "collateral", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"collateral\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgDepositCollateral>): MsgDepositCollateral {
        const message = { sender: "", to: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgDepositCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositCollateral): MsgDepositCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin collateral */ 3:
                    message.collateral = Coin.internalBinaryRead(reader, reader.uint32(), options, message.collateral);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDepositCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* cosmos.base.v1beta1.Coin collateral = 3; */
        if (message.collateral)
            Coin.internalBinaryWrite(message.collateral, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgDepositCollateral
 */
export const MsgDepositCollateral = new MsgDepositCollateral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDepositCollateralResponse$Type extends MessageType<MsgDepositCollateralResponse> {
    constructor() {
        super("merlion.maker.v1.MsgDepositCollateralResponse", []);
    }
    create(value?: PartialMessage<MsgDepositCollateralResponse>): MsgDepositCollateralResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgDepositCollateralResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDepositCollateralResponse): MsgDepositCollateralResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgDepositCollateralResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgDepositCollateralResponse
 */
export const MsgDepositCollateralResponse = new MsgDepositCollateralResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRedeemCollateral$Type extends MessageType<MsgRedeemCollateral> {
    constructor() {
        super("merlion.maker.v1.MsgRedeemCollateral", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "collateral", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"collateral\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgRedeemCollateral>): MsgRedeemCollateral {
        const message = { sender: "", to: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgRedeemCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRedeemCollateral): MsgRedeemCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin collateral */ 3:
                    message.collateral = Coin.internalBinaryRead(reader, reader.uint32(), options, message.collateral);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRedeemCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* cosmos.base.v1beta1.Coin collateral = 3; */
        if (message.collateral)
            Coin.internalBinaryWrite(message.collateral, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgRedeemCollateral
 */
export const MsgRedeemCollateral = new MsgRedeemCollateral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRedeemCollateralResponse$Type extends MessageType<MsgRedeemCollateralResponse> {
    constructor() {
        super("merlion.maker.v1.MsgRedeemCollateralResponse", []);
    }
    create(value?: PartialMessage<MsgRedeemCollateralResponse>): MsgRedeemCollateralResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgRedeemCollateralResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRedeemCollateralResponse): MsgRedeemCollateralResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgRedeemCollateralResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgRedeemCollateralResponse
 */
export const MsgRedeemCollateralResponse = new MsgRedeemCollateralResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLiquidateCollateral$Type extends MessageType<MsgLiquidateCollateral> {
    constructor() {
        super("merlion.maker.v1.MsgLiquidateCollateral", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"sender\"" } },
            { no: 2, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 3, name: "debtor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"to\"" } },
            { no: 4, name: "collateral", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"collateral\"" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgLiquidateCollateral>): MsgLiquidateCollateral {
        const message = { sender: "", to: "", debtor: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgLiquidateCollateral>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLiquidateCollateral): MsgLiquidateCollateral {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string to */ 2:
                    message.to = reader.string();
                    break;
                case /* string debtor */ 3:
                    message.debtor = reader.string();
                    break;
                case /* cosmos.base.v1beta1.Coin collateral */ 4:
                    message.collateral = Coin.internalBinaryRead(reader, reader.uint32(), options, message.collateral);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgLiquidateCollateral, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string to = 2; */
        if (message.to !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.to);
        /* string debtor = 3; */
        if (message.debtor !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.debtor);
        /* cosmos.base.v1beta1.Coin collateral = 4; */
        if (message.collateral)
            Coin.internalBinaryWrite(message.collateral, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgLiquidateCollateral
 */
export const MsgLiquidateCollateral = new MsgLiquidateCollateral$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgLiquidateCollateralResponse$Type extends MessageType<MsgLiquidateCollateralResponse> {
    constructor() {
        super("merlion.maker.v1.MsgLiquidateCollateralResponse", [
            { no: 1, name: "repay_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"repay_in\"" } },
            { no: 2, name: "collateral_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"collateral_out\"" } }
        ]);
    }
    create(value?: PartialMessage<MsgLiquidateCollateralResponse>): MsgLiquidateCollateralResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgLiquidateCollateralResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgLiquidateCollateralResponse): MsgLiquidateCollateralResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin repay_in */ 1:
                    message.repayIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.repayIn);
                    break;
                case /* cosmos.base.v1beta1.Coin collateral_out */ 2:
                    message.collateralOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.collateralOut);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgLiquidateCollateralResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin repay_in = 1; */
        if (message.repayIn)
            Coin.internalBinaryWrite(message.repayIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin collateral_out = 2; */
        if (message.collateralOut)
            Coin.internalBinaryWrite(message.collateralOut, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.MsgLiquidateCollateralResponse
 */
export const MsgLiquidateCollateralResponse = new MsgLiquidateCollateralResponse$Type();
/**
 * @generated ServiceType for protobuf service merlion.maker.v1.Msg
 */
export const Msg = new ServiceType("merlion.maker.v1.Msg", [
    { name: "MintBySwap", options: { "google.api.http": { get: "/merlion/maker/v1/tx/mint_by_swap" } }, I: MsgMintBySwap, O: MsgMintBySwapResponse },
    { name: "BurnBySwap", options: { "google.api.http": { get: "/merlion/maker/v1/tx/burn_by_swap" } }, I: MsgBurnBySwap, O: MsgBurnBySwapResponse },
    { name: "BuyBacking", options: { "google.api.http": { get: "/merlion/maker/v1/tx/buy_backing" } }, I: MsgBuyBacking, O: MsgBuyBackingResponse },
    { name: "SellBacking", options: { "google.api.http": { get: "/merlion/maker/v1/tx/sell_backing" } }, I: MsgSellBacking, O: MsgSellBackingResponse },
    { name: "MintByCollateral", options: { "google.api.http": { get: "/merlion/maker/v1/tx/mint_by_collateral" } }, I: MsgMintByCollateral, O: MsgMintByCollateralResponse },
    { name: "BurnByCollateral", options: { "google.api.http": { get: "/merlion/maker/v1/tx/burn_by_collateral" } }, I: MsgBurnByCollateral, O: MsgBurnByCollateralResponse },
    { name: "DepositCollateral", options: { "google.api.http": { get: "/merlion/maker/v1/tx/deposit_collateral" } }, I: MsgDepositCollateral, O: MsgDepositCollateralResponse },
    { name: "RedeemCollateral", options: { "google.api.http": { get: "/merlion/maker/v1/tx/redeem_collateral" } }, I: MsgRedeemCollateral, O: MsgRedeemCollateralResponse },
    { name: "LiquidateCollateral", options: { "google.api.http": { get: "/merlion/maker/v1/tx/liquidate_collateral" } }, I: MsgLiquidateCollateral, O: MsgLiquidateCollateralResponse }
]);
