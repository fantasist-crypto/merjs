// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "merlion/maker/v1/query.proto" (package "merlion.maker.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Params } from "./genesis";
import { TotalCollateral } from "./maker";
import { TotalBacking } from "./maker";
import { AccountCollateral } from "./maker";
import { PoolCollateral } from "./maker";
import { PoolBacking } from "./maker";
import { CollateralRiskParams } from "./maker";
import { BackingRiskParams } from "./maker";
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllBackingRiskParamsRequest
 */
export interface QueryAllBackingRiskParamsRequest {
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllBackingRiskParamsResponse
 */
export interface QueryAllBackingRiskParamsResponse {
    /**
     * @generated from protobuf field: repeated merlion.maker.v1.BackingRiskParams risk_params = 1;
     */
    riskParams: BackingRiskParams[];
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllCollateralRiskParamsRequest
 */
export interface QueryAllCollateralRiskParamsRequest {
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllCollateralRiskParamsResponse
 */
export interface QueryAllCollateralRiskParamsResponse {
    /**
     * @generated from protobuf field: repeated merlion.maker.v1.CollateralRiskParams risk_params = 1;
     */
    riskParams: CollateralRiskParams[];
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllBackingPoolsRequest
 */
export interface QueryAllBackingPoolsRequest {
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllBackingPoolsResponse
 */
export interface QueryAllBackingPoolsResponse {
    /**
     * @generated from protobuf field: repeated merlion.maker.v1.PoolBacking backing_pools = 1;
     */
    backingPools: PoolBacking[];
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllCollateralPoolsRequest
 */
export interface QueryAllCollateralPoolsRequest {
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryAllCollateralPoolsResponse
 */
export interface QueryAllCollateralPoolsResponse {
    /**
     * @generated from protobuf field: repeated merlion.maker.v1.PoolCollateral collateral_pools = 1;
     */
    collateralPools: PoolCollateral[];
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryBackingPoolRequest
 */
export interface QueryBackingPoolRequest {
    /**
     * @generated from protobuf field: string backing_denom = 1;
     */
    backingDenom: string;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryBackingPoolResponse
 */
export interface QueryBackingPoolResponse {
    /**
     * @generated from protobuf field: merlion.maker.v1.PoolBacking backing_pool = 1;
     */
    backingPool?: PoolBacking;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryCollateralPoolRequest
 */
export interface QueryCollateralPoolRequest {
    /**
     * @generated from protobuf field: string collateral_denom = 1;
     */
    collateralDenom: string;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryCollateralPoolResponse
 */
export interface QueryCollateralPoolResponse {
    /**
     * @generated from protobuf field: merlion.maker.v1.PoolCollateral collateral_pool = 1;
     */
    collateralPool?: PoolCollateral;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryCollateralOfAccountRequest
 */
export interface QueryCollateralOfAccountRequest {
    /**
     * @generated from protobuf field: string account = 1;
     */
    account: string;
    /**
     * @generated from protobuf field: string collateral_denom = 2;
     */
    collateralDenom: string;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryCollateralOfAccountResponse
 */
export interface QueryCollateralOfAccountResponse {
    /**
     * @generated from protobuf field: merlion.maker.v1.AccountCollateral account_collateral = 1;
     */
    accountCollateral?: AccountCollateral;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryTotalBackingRequest
 */
export interface QueryTotalBackingRequest {
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryTotalBackingResponse
 */
export interface QueryTotalBackingResponse {
    /**
     * @generated from protobuf field: merlion.maker.v1.TotalBacking total_backing = 1;
     */
    totalBacking?: TotalBacking;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryTotalCollateralRequest
 */
export interface QueryTotalCollateralRequest {
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryTotalCollateralResponse
 */
export interface QueryTotalCollateralResponse {
    /**
     * @generated from protobuf field: merlion.maker.v1.TotalCollateral total_collateral = 1;
     */
    totalCollateral?: TotalCollateral;
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryBackingRatioRequest
 */
export interface QueryBackingRatioRequest {
}
/**
 * @generated from protobuf message merlion.maker.v1.QueryBackingRatioResponse
 */
export interface QueryBackingRatioResponse {
    /**
     * @generated from protobuf field: string backing_ratio = 1;
     */
    backingRatio: string;
    /**
     * @generated from protobuf field: int64 last_update_block = 2;
     */
    lastUpdateBlock: string;
}
/**
 * QueryParamsRequest is request type for the Query/Params RPC method.
 *
 * @generated from protobuf message merlion.maker.v1.QueryParamsRequest
 */
export interface QueryParamsRequest {
}
/**
 * QueryParamsResponse is response type for the Query/Params RPC method.
 *
 * @generated from protobuf message merlion.maker.v1.QueryParamsResponse
 */
export interface QueryParamsResponse {
    /**
     * params holds all the parameters of this module.
     *
     * @generated from protobuf field: merlion.maker.v1.Params params = 1;
     */
    params?: Params;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateMintBySwapInRequest
 */
export interface EstimateMintBySwapInRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_out = 1;
     */
    mintOut?: Coin;
    /**
     * @generated from protobuf field: string backing_denom = 2;
     */
    backingDenom: string;
    /**
     * @generated from protobuf field: bool full_backing = 3;
     */
    fullBacking: boolean;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateMintBySwapInResponse
 */
export interface EstimateMintBySwapInResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in = 1;
     */
    backingIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in = 2;
     */
    lionIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_fee = 3;
     */
    mintFee?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateMintBySwapOutRequest
 */
export interface EstimateMintBySwapOutRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in_max = 1;
     */
    backingInMax?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in_max = 2;
     */
    lionInMax?: Coin;
    /**
     * @generated from protobuf field: bool full_backing = 3;
     */
    fullBacking: boolean;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateMintBySwapOutResponse
 */
export interface EstimateMintBySwapOutResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in = 1;
     */
    backingIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in = 2;
     */
    lionIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_out = 3;
     */
    mintOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin mint_fee = 4;
     */
    mintFee?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBurnBySwapInRequest
 */
export interface EstimateBurnBySwapInRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out_max = 1;
     */
    backingOutMax?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out_max = 2;
     */
    lionOutMax?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBurnBySwapInResponse
 */
export interface EstimateBurnBySwapInResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin burn_in = 1;
     */
    burnIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out = 2;
     */
    backingOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out = 3;
     */
    lionOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin burn_fee = 4;
     */
    burnFee?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBurnBySwapOutRequest
 */
export interface EstimateBurnBySwapOutRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin burn_in = 1;
     */
    burnIn?: Coin;
    /**
     * @generated from protobuf field: string backing_denom = 2;
     */
    backingDenom: string;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBurnBySwapOutResponse
 */
export interface EstimateBurnBySwapOutResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out = 1;
     */
    backingOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out = 2;
     */
    lionOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin burn_fee = 3;
     */
    burnFee?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBuyBackingInRequest
 */
export interface EstimateBuyBackingInRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out = 1;
     */
    backingOut?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBuyBackingInResponse
 */
export interface EstimateBuyBackingInResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in = 1;
     */
    lionIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin buyback_fee = 2;
     */
    buybackFee?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBuyBackingOutRequest
 */
export interface EstimateBuyBackingOutRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_in = 1;
     */
    lionIn?: Coin;
    /**
     * @generated from protobuf field: string backing_denom = 2;
     */
    backingDenom: string;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateBuyBackingOutResponse
 */
export interface EstimateBuyBackingOutResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_out = 1;
     */
    backingOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin buyback_fee = 2;
     */
    buybackFee?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateSellBackingInRequest
 */
export interface EstimateSellBackingInRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out = 1;
     */
    lionOut?: Coin;
    /**
     * @generated from protobuf field: string backing_denom = 2;
     */
    backingDenom: string;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateSellBackingInResponse
 */
export interface EstimateSellBackingInResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in = 1;
     */
    backingIn?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin sellback_fee = 2;
     */
    sellbackFee?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateSellBackingOutRequest
 */
export interface EstimateSellBackingOutRequest {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin backing_in = 1;
     */
    backingIn?: Coin;
}
/**
 * @generated from protobuf message merlion.maker.v1.EstimateSellBackingOutResponse
 */
export interface EstimateSellBackingOutResponse {
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin lion_out = 1;
     */
    lionOut?: Coin;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin sellback_fee = 2;
     */
    sellbackFee?: Coin;
}
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllBackingRiskParamsRequest$Type extends MessageType<QueryAllBackingRiskParamsRequest> {
    constructor() {
        super("merlion.maker.v1.QueryAllBackingRiskParamsRequest", []);
    }
    create(value?: PartialMessage<QueryAllBackingRiskParamsRequest>): QueryAllBackingRiskParamsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllBackingRiskParamsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllBackingRiskParamsRequest): QueryAllBackingRiskParamsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryAllBackingRiskParamsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllBackingRiskParamsRequest
 */
export const QueryAllBackingRiskParamsRequest = new QueryAllBackingRiskParamsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllBackingRiskParamsResponse$Type extends MessageType<QueryAllBackingRiskParamsResponse> {
    constructor() {
        super("merlion.maker.v1.QueryAllBackingRiskParamsResponse", [
            { no: 1, name: "risk_params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BackingRiskParams, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryAllBackingRiskParamsResponse>): QueryAllBackingRiskParamsResponse {
        const message = { riskParams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllBackingRiskParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllBackingRiskParamsResponse): QueryAllBackingRiskParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated merlion.maker.v1.BackingRiskParams risk_params */ 1:
                    message.riskParams.push(BackingRiskParams.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAllBackingRiskParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated merlion.maker.v1.BackingRiskParams risk_params = 1; */
        for (let i = 0; i < message.riskParams.length; i++)
            BackingRiskParams.internalBinaryWrite(message.riskParams[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllBackingRiskParamsResponse
 */
export const QueryAllBackingRiskParamsResponse = new QueryAllBackingRiskParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllCollateralRiskParamsRequest$Type extends MessageType<QueryAllCollateralRiskParamsRequest> {
    constructor() {
        super("merlion.maker.v1.QueryAllCollateralRiskParamsRequest", []);
    }
    create(value?: PartialMessage<QueryAllCollateralRiskParamsRequest>): QueryAllCollateralRiskParamsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllCollateralRiskParamsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllCollateralRiskParamsRequest): QueryAllCollateralRiskParamsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryAllCollateralRiskParamsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllCollateralRiskParamsRequest
 */
export const QueryAllCollateralRiskParamsRequest = new QueryAllCollateralRiskParamsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllCollateralRiskParamsResponse$Type extends MessageType<QueryAllCollateralRiskParamsResponse> {
    constructor() {
        super("merlion.maker.v1.QueryAllCollateralRiskParamsResponse", [
            { no: 1, name: "risk_params", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CollateralRiskParams, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryAllCollateralRiskParamsResponse>): QueryAllCollateralRiskParamsResponse {
        const message = { riskParams: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllCollateralRiskParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllCollateralRiskParamsResponse): QueryAllCollateralRiskParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated merlion.maker.v1.CollateralRiskParams risk_params */ 1:
                    message.riskParams.push(CollateralRiskParams.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAllCollateralRiskParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated merlion.maker.v1.CollateralRiskParams risk_params = 1; */
        for (let i = 0; i < message.riskParams.length; i++)
            CollateralRiskParams.internalBinaryWrite(message.riskParams[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllCollateralRiskParamsResponse
 */
export const QueryAllCollateralRiskParamsResponse = new QueryAllCollateralRiskParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllBackingPoolsRequest$Type extends MessageType<QueryAllBackingPoolsRequest> {
    constructor() {
        super("merlion.maker.v1.QueryAllBackingPoolsRequest", []);
    }
    create(value?: PartialMessage<QueryAllBackingPoolsRequest>): QueryAllBackingPoolsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllBackingPoolsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllBackingPoolsRequest): QueryAllBackingPoolsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryAllBackingPoolsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllBackingPoolsRequest
 */
export const QueryAllBackingPoolsRequest = new QueryAllBackingPoolsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllBackingPoolsResponse$Type extends MessageType<QueryAllBackingPoolsResponse> {
    constructor() {
        super("merlion.maker.v1.QueryAllBackingPoolsResponse", [
            { no: 1, name: "backing_pools", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PoolBacking, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryAllBackingPoolsResponse>): QueryAllBackingPoolsResponse {
        const message = { backingPools: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllBackingPoolsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllBackingPoolsResponse): QueryAllBackingPoolsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated merlion.maker.v1.PoolBacking backing_pools */ 1:
                    message.backingPools.push(PoolBacking.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAllBackingPoolsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated merlion.maker.v1.PoolBacking backing_pools = 1; */
        for (let i = 0; i < message.backingPools.length; i++)
            PoolBacking.internalBinaryWrite(message.backingPools[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllBackingPoolsResponse
 */
export const QueryAllBackingPoolsResponse = new QueryAllBackingPoolsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllCollateralPoolsRequest$Type extends MessageType<QueryAllCollateralPoolsRequest> {
    constructor() {
        super("merlion.maker.v1.QueryAllCollateralPoolsRequest", []);
    }
    create(value?: PartialMessage<QueryAllCollateralPoolsRequest>): QueryAllCollateralPoolsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllCollateralPoolsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllCollateralPoolsRequest): QueryAllCollateralPoolsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryAllCollateralPoolsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllCollateralPoolsRequest
 */
export const QueryAllCollateralPoolsRequest = new QueryAllCollateralPoolsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryAllCollateralPoolsResponse$Type extends MessageType<QueryAllCollateralPoolsResponse> {
    constructor() {
        super("merlion.maker.v1.QueryAllCollateralPoolsResponse", [
            { no: 1, name: "collateral_pools", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PoolCollateral, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryAllCollateralPoolsResponse>): QueryAllCollateralPoolsResponse {
        const message = { collateralPools: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryAllCollateralPoolsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryAllCollateralPoolsResponse): QueryAllCollateralPoolsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated merlion.maker.v1.PoolCollateral collateral_pools */ 1:
                    message.collateralPools.push(PoolCollateral.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryAllCollateralPoolsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated merlion.maker.v1.PoolCollateral collateral_pools = 1; */
        for (let i = 0; i < message.collateralPools.length; i++)
            PoolCollateral.internalBinaryWrite(message.collateralPools[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryAllCollateralPoolsResponse
 */
export const QueryAllCollateralPoolsResponse = new QueryAllCollateralPoolsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBackingPoolRequest$Type extends MessageType<QueryBackingPoolRequest> {
    constructor() {
        super("merlion.maker.v1.QueryBackingPoolRequest", [
            { no: 1, name: "backing_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryBackingPoolRequest>): QueryBackingPoolRequest {
        const message = { backingDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryBackingPoolRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBackingPoolRequest): QueryBackingPoolRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string backing_denom */ 1:
                    message.backingDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBackingPoolRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string backing_denom = 1; */
        if (message.backingDenom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.backingDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryBackingPoolRequest
 */
export const QueryBackingPoolRequest = new QueryBackingPoolRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBackingPoolResponse$Type extends MessageType<QueryBackingPoolResponse> {
    constructor() {
        super("merlion.maker.v1.QueryBackingPoolResponse", [
            { no: 1, name: "backing_pool", kind: "message", T: () => PoolBacking, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryBackingPoolResponse>): QueryBackingPoolResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryBackingPoolResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBackingPoolResponse): QueryBackingPoolResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* merlion.maker.v1.PoolBacking backing_pool */ 1:
                    message.backingPool = PoolBacking.internalBinaryRead(reader, reader.uint32(), options, message.backingPool);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBackingPoolResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* merlion.maker.v1.PoolBacking backing_pool = 1; */
        if (message.backingPool)
            PoolBacking.internalBinaryWrite(message.backingPool, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryBackingPoolResponse
 */
export const QueryBackingPoolResponse = new QueryBackingPoolResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCollateralPoolRequest$Type extends MessageType<QueryCollateralPoolRequest> {
    constructor() {
        super("merlion.maker.v1.QueryCollateralPoolRequest", [
            { no: 1, name: "collateral_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryCollateralPoolRequest>): QueryCollateralPoolRequest {
        const message = { collateralDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryCollateralPoolRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCollateralPoolRequest): QueryCollateralPoolRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string collateral_denom */ 1:
                    message.collateralDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCollateralPoolRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string collateral_denom = 1; */
        if (message.collateralDenom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.collateralDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryCollateralPoolRequest
 */
export const QueryCollateralPoolRequest = new QueryCollateralPoolRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCollateralPoolResponse$Type extends MessageType<QueryCollateralPoolResponse> {
    constructor() {
        super("merlion.maker.v1.QueryCollateralPoolResponse", [
            { no: 1, name: "collateral_pool", kind: "message", T: () => PoolCollateral, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryCollateralPoolResponse>): QueryCollateralPoolResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryCollateralPoolResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCollateralPoolResponse): QueryCollateralPoolResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* merlion.maker.v1.PoolCollateral collateral_pool */ 1:
                    message.collateralPool = PoolCollateral.internalBinaryRead(reader, reader.uint32(), options, message.collateralPool);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCollateralPoolResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* merlion.maker.v1.PoolCollateral collateral_pool = 1; */
        if (message.collateralPool)
            PoolCollateral.internalBinaryWrite(message.collateralPool, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryCollateralPoolResponse
 */
export const QueryCollateralPoolResponse = new QueryCollateralPoolResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCollateralOfAccountRequest$Type extends MessageType<QueryCollateralOfAccountRequest> {
    constructor() {
        super("merlion.maker.v1.QueryCollateralOfAccountRequest", [
            { no: 1, name: "account", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "collateral_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryCollateralOfAccountRequest>): QueryCollateralOfAccountRequest {
        const message = { account: "", collateralDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryCollateralOfAccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCollateralOfAccountRequest): QueryCollateralOfAccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account */ 1:
                    message.account = reader.string();
                    break;
                case /* string collateral_denom */ 2:
                    message.collateralDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCollateralOfAccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account = 1; */
        if (message.account !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.account);
        /* string collateral_denom = 2; */
        if (message.collateralDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.collateralDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryCollateralOfAccountRequest
 */
export const QueryCollateralOfAccountRequest = new QueryCollateralOfAccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryCollateralOfAccountResponse$Type extends MessageType<QueryCollateralOfAccountResponse> {
    constructor() {
        super("merlion.maker.v1.QueryCollateralOfAccountResponse", [
            { no: 1, name: "account_collateral", kind: "message", T: () => AccountCollateral, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryCollateralOfAccountResponse>): QueryCollateralOfAccountResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryCollateralOfAccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryCollateralOfAccountResponse): QueryCollateralOfAccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* merlion.maker.v1.AccountCollateral account_collateral */ 1:
                    message.accountCollateral = AccountCollateral.internalBinaryRead(reader, reader.uint32(), options, message.accountCollateral);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryCollateralOfAccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* merlion.maker.v1.AccountCollateral account_collateral = 1; */
        if (message.accountCollateral)
            AccountCollateral.internalBinaryWrite(message.accountCollateral, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryCollateralOfAccountResponse
 */
export const QueryCollateralOfAccountResponse = new QueryCollateralOfAccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTotalBackingRequest$Type extends MessageType<QueryTotalBackingRequest> {
    constructor() {
        super("merlion.maker.v1.QueryTotalBackingRequest", []);
    }
    create(value?: PartialMessage<QueryTotalBackingRequest>): QueryTotalBackingRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryTotalBackingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTotalBackingRequest): QueryTotalBackingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryTotalBackingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryTotalBackingRequest
 */
export const QueryTotalBackingRequest = new QueryTotalBackingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTotalBackingResponse$Type extends MessageType<QueryTotalBackingResponse> {
    constructor() {
        super("merlion.maker.v1.QueryTotalBackingResponse", [
            { no: 1, name: "total_backing", kind: "message", T: () => TotalBacking, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryTotalBackingResponse>): QueryTotalBackingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryTotalBackingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTotalBackingResponse): QueryTotalBackingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* merlion.maker.v1.TotalBacking total_backing */ 1:
                    message.totalBacking = TotalBacking.internalBinaryRead(reader, reader.uint32(), options, message.totalBacking);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTotalBackingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* merlion.maker.v1.TotalBacking total_backing = 1; */
        if (message.totalBacking)
            TotalBacking.internalBinaryWrite(message.totalBacking, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryTotalBackingResponse
 */
export const QueryTotalBackingResponse = new QueryTotalBackingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTotalCollateralRequest$Type extends MessageType<QueryTotalCollateralRequest> {
    constructor() {
        super("merlion.maker.v1.QueryTotalCollateralRequest", []);
    }
    create(value?: PartialMessage<QueryTotalCollateralRequest>): QueryTotalCollateralRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryTotalCollateralRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTotalCollateralRequest): QueryTotalCollateralRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryTotalCollateralRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryTotalCollateralRequest
 */
export const QueryTotalCollateralRequest = new QueryTotalCollateralRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryTotalCollateralResponse$Type extends MessageType<QueryTotalCollateralResponse> {
    constructor() {
        super("merlion.maker.v1.QueryTotalCollateralResponse", [
            { no: 1, name: "total_collateral", kind: "message", T: () => TotalCollateral, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryTotalCollateralResponse>): QueryTotalCollateralResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryTotalCollateralResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryTotalCollateralResponse): QueryTotalCollateralResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* merlion.maker.v1.TotalCollateral total_collateral */ 1:
                    message.totalCollateral = TotalCollateral.internalBinaryRead(reader, reader.uint32(), options, message.totalCollateral);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryTotalCollateralResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* merlion.maker.v1.TotalCollateral total_collateral = 1; */
        if (message.totalCollateral)
            TotalCollateral.internalBinaryWrite(message.totalCollateral, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryTotalCollateralResponse
 */
export const QueryTotalCollateralResponse = new QueryTotalCollateralResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBackingRatioRequest$Type extends MessageType<QueryBackingRatioRequest> {
    constructor() {
        super("merlion.maker.v1.QueryBackingRatioRequest", []);
    }
    create(value?: PartialMessage<QueryBackingRatioRequest>): QueryBackingRatioRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryBackingRatioRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBackingRatioRequest): QueryBackingRatioRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryBackingRatioRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryBackingRatioRequest
 */
export const QueryBackingRatioRequest = new QueryBackingRatioRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryBackingRatioResponse$Type extends MessageType<QueryBackingRatioResponse> {
    constructor() {
        super("merlion.maker.v1.QueryBackingRatioResponse", [
            { no: 1, name: "backing_ratio", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Dec" } },
            { no: 2, name: "last_update_block", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryBackingRatioResponse>): QueryBackingRatioResponse {
        const message = { backingRatio: "", lastUpdateBlock: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryBackingRatioResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryBackingRatioResponse): QueryBackingRatioResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string backing_ratio */ 1:
                    message.backingRatio = reader.string();
                    break;
                case /* int64 last_update_block */ 2:
                    message.lastUpdateBlock = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryBackingRatioResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string backing_ratio = 1; */
        if (message.backingRatio !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.backingRatio);
        /* int64 last_update_block = 2; */
        if (message.lastUpdateBlock !== "0")
            writer.tag(2, WireType.Varint).int64(message.lastUpdateBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryBackingRatioResponse
 */
export const QueryBackingRatioResponse = new QueryBackingRatioResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParamsRequest$Type extends MessageType<QueryParamsRequest> {
    constructor() {
        super("merlion.maker.v1.QueryParamsRequest", []);
    }
    create(value?: PartialMessage<QueryParamsRequest>): QueryParamsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryParamsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParamsRequest): QueryParamsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: QueryParamsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryParamsRequest
 */
export const QueryParamsRequest = new QueryParamsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParamsResponse$Type extends MessageType<QueryParamsResponse> {
    constructor() {
        super("merlion.maker.v1.QueryParamsResponse", [
            { no: 1, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryParamsResponse>): QueryParamsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParamsResponse): QueryParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* merlion.maker.v1.Params params */ 1:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* merlion.maker.v1.Params params = 1; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.QueryParamsResponse
 */
export const QueryParamsResponse = new QueryParamsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateMintBySwapInRequest$Type extends MessageType<EstimateMintBySwapInRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateMintBySwapInRequest", [
            { no: 1, name: "mint_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "backing_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "full_backing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateMintBySwapInRequest>): EstimateMintBySwapInRequest {
        const message = { backingDenom: "", fullBacking: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateMintBySwapInRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateMintBySwapInRequest): EstimateMintBySwapInRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin mint_out */ 1:
                    message.mintOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintOut);
                    break;
                case /* string backing_denom */ 2:
                    message.backingDenom = reader.string();
                    break;
                case /* bool full_backing */ 3:
                    message.fullBacking = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateMintBySwapInRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin mint_out = 1; */
        if (message.mintOut)
            Coin.internalBinaryWrite(message.mintOut, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string backing_denom = 2; */
        if (message.backingDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.backingDenom);
        /* bool full_backing = 3; */
        if (message.fullBacking !== false)
            writer.tag(3, WireType.Varint).bool(message.fullBacking);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateMintBySwapInRequest
 */
export const EstimateMintBySwapInRequest = new EstimateMintBySwapInRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateMintBySwapInResponse$Type extends MessageType<EstimateMintBySwapInResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateMintBySwapInResponse", [
            { no: 1, name: "backing_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "lion_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "mint_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateMintBySwapInResponse>): EstimateMintBySwapInResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateMintBySwapInResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateMintBySwapInResponse): EstimateMintBySwapInResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_in */ 1:
                    message.backingIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingIn);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in */ 2:
                    message.lionIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionIn);
                    break;
                case /* cosmos.base.v1beta1.Coin mint_fee */ 3:
                    message.mintFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateMintBySwapInResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_in = 1; */
        if (message.backingIn)
            Coin.internalBinaryWrite(message.backingIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_in = 2; */
        if (message.lionIn)
            Coin.internalBinaryWrite(message.lionIn, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mint_fee = 3; */
        if (message.mintFee)
            Coin.internalBinaryWrite(message.mintFee, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateMintBySwapInResponse
 */
export const EstimateMintBySwapInResponse = new EstimateMintBySwapInResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateMintBySwapOutRequest$Type extends MessageType<EstimateMintBySwapOutRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateMintBySwapOutRequest", [
            { no: 1, name: "backing_in_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "lion_in_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "full_backing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateMintBySwapOutRequest>): EstimateMintBySwapOutRequest {
        const message = { fullBacking: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateMintBySwapOutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateMintBySwapOutRequest): EstimateMintBySwapOutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_in_max */ 1:
                    message.backingInMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingInMax);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in_max */ 2:
                    message.lionInMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionInMax);
                    break;
                case /* bool full_backing */ 3:
                    message.fullBacking = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateMintBySwapOutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_in_max = 1; */
        if (message.backingInMax)
            Coin.internalBinaryWrite(message.backingInMax, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_in_max = 2; */
        if (message.lionInMax)
            Coin.internalBinaryWrite(message.lionInMax, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool full_backing = 3; */
        if (message.fullBacking !== false)
            writer.tag(3, WireType.Varint).bool(message.fullBacking);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateMintBySwapOutRequest
 */
export const EstimateMintBySwapOutRequest = new EstimateMintBySwapOutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateMintBySwapOutResponse$Type extends MessageType<EstimateMintBySwapOutResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateMintBySwapOutResponse", [
            { no: 1, name: "backing_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "lion_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "mint_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 4, name: "mint_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateMintBySwapOutResponse>): EstimateMintBySwapOutResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateMintBySwapOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateMintBySwapOutResponse): EstimateMintBySwapOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_in */ 1:
                    message.backingIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingIn);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_in */ 2:
                    message.lionIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionIn);
                    break;
                case /* cosmos.base.v1beta1.Coin mint_out */ 3:
                    message.mintOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintOut);
                    break;
                case /* cosmos.base.v1beta1.Coin mint_fee */ 4:
                    message.mintFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.mintFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateMintBySwapOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_in = 1; */
        if (message.backingIn)
            Coin.internalBinaryWrite(message.backingIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_in = 2; */
        if (message.lionIn)
            Coin.internalBinaryWrite(message.lionIn, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mint_out = 3; */
        if (message.mintOut)
            Coin.internalBinaryWrite(message.mintOut, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin mint_fee = 4; */
        if (message.mintFee)
            Coin.internalBinaryWrite(message.mintFee, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateMintBySwapOutResponse
 */
export const EstimateMintBySwapOutResponse = new EstimateMintBySwapOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBurnBySwapInRequest$Type extends MessageType<EstimateBurnBySwapInRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateBurnBySwapInRequest", [
            { no: 1, name: "backing_out_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "lion_out_max", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateBurnBySwapInRequest>): EstimateBurnBySwapInRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBurnBySwapInRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBurnBySwapInRequest): EstimateBurnBySwapInRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_out_max */ 1:
                    message.backingOutMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOutMax);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_out_max */ 2:
                    message.lionOutMax = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOutMax);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBurnBySwapInRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_out_max = 1; */
        if (message.backingOutMax)
            Coin.internalBinaryWrite(message.backingOutMax, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_out_max = 2; */
        if (message.lionOutMax)
            Coin.internalBinaryWrite(message.lionOutMax, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBurnBySwapInRequest
 */
export const EstimateBurnBySwapInRequest = new EstimateBurnBySwapInRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBurnBySwapInResponse$Type extends MessageType<EstimateBurnBySwapInResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateBurnBySwapInResponse", [
            { no: 1, name: "burn_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "backing_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "lion_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 4, name: "burn_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateBurnBySwapInResponse>): EstimateBurnBySwapInResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBurnBySwapInResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBurnBySwapInResponse): EstimateBurnBySwapInResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin burn_in */ 1:
                    message.burnIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.burnIn);
                    break;
                case /* cosmos.base.v1beta1.Coin backing_out */ 2:
                    message.backingOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOut);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_out */ 3:
                    message.lionOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOut);
                    break;
                case /* cosmos.base.v1beta1.Coin burn_fee */ 4:
                    message.burnFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.burnFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBurnBySwapInResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin burn_in = 1; */
        if (message.burnIn)
            Coin.internalBinaryWrite(message.burnIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin backing_out = 2; */
        if (message.backingOut)
            Coin.internalBinaryWrite(message.backingOut, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_out = 3; */
        if (message.lionOut)
            Coin.internalBinaryWrite(message.lionOut, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin burn_fee = 4; */
        if (message.burnFee)
            Coin.internalBinaryWrite(message.burnFee, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBurnBySwapInResponse
 */
export const EstimateBurnBySwapInResponse = new EstimateBurnBySwapInResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBurnBySwapOutRequest$Type extends MessageType<EstimateBurnBySwapOutRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateBurnBySwapOutRequest", [
            { no: 1, name: "burn_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "backing_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateBurnBySwapOutRequest>): EstimateBurnBySwapOutRequest {
        const message = { backingDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBurnBySwapOutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBurnBySwapOutRequest): EstimateBurnBySwapOutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin burn_in */ 1:
                    message.burnIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.burnIn);
                    break;
                case /* string backing_denom */ 2:
                    message.backingDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBurnBySwapOutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin burn_in = 1; */
        if (message.burnIn)
            Coin.internalBinaryWrite(message.burnIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string backing_denom = 2; */
        if (message.backingDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.backingDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBurnBySwapOutRequest
 */
export const EstimateBurnBySwapOutRequest = new EstimateBurnBySwapOutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBurnBySwapOutResponse$Type extends MessageType<EstimateBurnBySwapOutResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateBurnBySwapOutResponse", [
            { no: 1, name: "backing_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "lion_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 3, name: "burn_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateBurnBySwapOutResponse>): EstimateBurnBySwapOutResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBurnBySwapOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBurnBySwapOutResponse): EstimateBurnBySwapOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_out */ 1:
                    message.backingOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOut);
                    break;
                case /* cosmos.base.v1beta1.Coin lion_out */ 2:
                    message.lionOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOut);
                    break;
                case /* cosmos.base.v1beta1.Coin burn_fee */ 3:
                    message.burnFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.burnFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBurnBySwapOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_out = 1; */
        if (message.backingOut)
            Coin.internalBinaryWrite(message.backingOut, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin lion_out = 2; */
        if (message.lionOut)
            Coin.internalBinaryWrite(message.lionOut, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin burn_fee = 3; */
        if (message.burnFee)
            Coin.internalBinaryWrite(message.burnFee, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBurnBySwapOutResponse
 */
export const EstimateBurnBySwapOutResponse = new EstimateBurnBySwapOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBuyBackingInRequest$Type extends MessageType<EstimateBuyBackingInRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateBuyBackingInRequest", [
            { no: 1, name: "backing_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateBuyBackingInRequest>): EstimateBuyBackingInRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBuyBackingInRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBuyBackingInRequest): EstimateBuyBackingInRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_out */ 1:
                    message.backingOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOut);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBuyBackingInRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_out = 1; */
        if (message.backingOut)
            Coin.internalBinaryWrite(message.backingOut, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBuyBackingInRequest
 */
export const EstimateBuyBackingInRequest = new EstimateBuyBackingInRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBuyBackingInResponse$Type extends MessageType<EstimateBuyBackingInResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateBuyBackingInResponse", [
            { no: 1, name: "lion_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "buyback_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateBuyBackingInResponse>): EstimateBuyBackingInResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBuyBackingInResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBuyBackingInResponse): EstimateBuyBackingInResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin lion_in */ 1:
                    message.lionIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionIn);
                    break;
                case /* cosmos.base.v1beta1.Coin buyback_fee */ 2:
                    message.buybackFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.buybackFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBuyBackingInResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin lion_in = 1; */
        if (message.lionIn)
            Coin.internalBinaryWrite(message.lionIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin buyback_fee = 2; */
        if (message.buybackFee)
            Coin.internalBinaryWrite(message.buybackFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBuyBackingInResponse
 */
export const EstimateBuyBackingInResponse = new EstimateBuyBackingInResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBuyBackingOutRequest$Type extends MessageType<EstimateBuyBackingOutRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateBuyBackingOutRequest", [
            { no: 1, name: "lion_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "backing_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateBuyBackingOutRequest>): EstimateBuyBackingOutRequest {
        const message = { backingDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBuyBackingOutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBuyBackingOutRequest): EstimateBuyBackingOutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin lion_in */ 1:
                    message.lionIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionIn);
                    break;
                case /* string backing_denom */ 2:
                    message.backingDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBuyBackingOutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin lion_in = 1; */
        if (message.lionIn)
            Coin.internalBinaryWrite(message.lionIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string backing_denom = 2; */
        if (message.backingDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.backingDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBuyBackingOutRequest
 */
export const EstimateBuyBackingOutRequest = new EstimateBuyBackingOutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateBuyBackingOutResponse$Type extends MessageType<EstimateBuyBackingOutResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateBuyBackingOutResponse", [
            { no: 1, name: "backing_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "buyback_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateBuyBackingOutResponse>): EstimateBuyBackingOutResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateBuyBackingOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateBuyBackingOutResponse): EstimateBuyBackingOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_out */ 1:
                    message.backingOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingOut);
                    break;
                case /* cosmos.base.v1beta1.Coin buyback_fee */ 2:
                    message.buybackFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.buybackFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateBuyBackingOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_out = 1; */
        if (message.backingOut)
            Coin.internalBinaryWrite(message.backingOut, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin buyback_fee = 2; */
        if (message.buybackFee)
            Coin.internalBinaryWrite(message.buybackFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateBuyBackingOutResponse
 */
export const EstimateBuyBackingOutResponse = new EstimateBuyBackingOutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateSellBackingInRequest$Type extends MessageType<EstimateSellBackingInRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateSellBackingInRequest", [
            { no: 1, name: "lion_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "backing_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EstimateSellBackingInRequest>): EstimateSellBackingInRequest {
        const message = { backingDenom: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateSellBackingInRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateSellBackingInRequest): EstimateSellBackingInRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin lion_out */ 1:
                    message.lionOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOut);
                    break;
                case /* string backing_denom */ 2:
                    message.backingDenom = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateSellBackingInRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin lion_out = 1; */
        if (message.lionOut)
            Coin.internalBinaryWrite(message.lionOut, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string backing_denom = 2; */
        if (message.backingDenom !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.backingDenom);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateSellBackingInRequest
 */
export const EstimateSellBackingInRequest = new EstimateSellBackingInRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateSellBackingInResponse$Type extends MessageType<EstimateSellBackingInResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateSellBackingInResponse", [
            { no: 1, name: "backing_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "sellback_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateSellBackingInResponse>): EstimateSellBackingInResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateSellBackingInResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateSellBackingInResponse): EstimateSellBackingInResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_in */ 1:
                    message.backingIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingIn);
                    break;
                case /* cosmos.base.v1beta1.Coin sellback_fee */ 2:
                    message.sellbackFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.sellbackFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateSellBackingInResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_in = 1; */
        if (message.backingIn)
            Coin.internalBinaryWrite(message.backingIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin sellback_fee = 2; */
        if (message.sellbackFee)
            Coin.internalBinaryWrite(message.sellbackFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateSellBackingInResponse
 */
export const EstimateSellBackingInResponse = new EstimateSellBackingInResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateSellBackingOutRequest$Type extends MessageType<EstimateSellBackingOutRequest> {
    constructor() {
        super("merlion.maker.v1.EstimateSellBackingOutRequest", [
            { no: 1, name: "backing_in", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateSellBackingOutRequest>): EstimateSellBackingOutRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateSellBackingOutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateSellBackingOutRequest): EstimateSellBackingOutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin backing_in */ 1:
                    message.backingIn = Coin.internalBinaryRead(reader, reader.uint32(), options, message.backingIn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateSellBackingOutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin backing_in = 1; */
        if (message.backingIn)
            Coin.internalBinaryWrite(message.backingIn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateSellBackingOutRequest
 */
export const EstimateSellBackingOutRequest = new EstimateSellBackingOutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimateSellBackingOutResponse$Type extends MessageType<EstimateSellBackingOutResponse> {
    constructor() {
        super("merlion.maker.v1.EstimateSellBackingOutResponse", [
            { no: 1, name: "lion_out", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } },
            { no: 2, name: "sellback_fee", kind: "message", T: () => Coin, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<EstimateSellBackingOutResponse>): EstimateSellBackingOutResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimateSellBackingOutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimateSellBackingOutResponse): EstimateSellBackingOutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.v1beta1.Coin lion_out */ 1:
                    message.lionOut = Coin.internalBinaryRead(reader, reader.uint32(), options, message.lionOut);
                    break;
                case /* cosmos.base.v1beta1.Coin sellback_fee */ 2:
                    message.sellbackFee = Coin.internalBinaryRead(reader, reader.uint32(), options, message.sellbackFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimateSellBackingOutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.v1beta1.Coin lion_out = 1; */
        if (message.lionOut)
            Coin.internalBinaryWrite(message.lionOut, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.v1beta1.Coin sellback_fee = 2; */
        if (message.sellbackFee)
            Coin.internalBinaryWrite(message.sellbackFee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message merlion.maker.v1.EstimateSellBackingOutResponse
 */
export const EstimateSellBackingOutResponse = new EstimateSellBackingOutResponse$Type();
/**
 * @generated ServiceType for protobuf service merlion.maker.v1.Query
 */
export const Query = new ServiceType("merlion.maker.v1.Query", [
    { name: "AllBackingRiskParams", options: { "google.api.http": { get: "/merlion/maker/v1/all_backing_risk_params" } }, I: QueryAllBackingRiskParamsRequest, O: QueryAllBackingRiskParamsResponse },
    { name: "AllCollateralRiskParams", options: { "google.api.http": { get: "/merlion/maker/v1/all_collateral_risk_params" } }, I: QueryAllCollateralRiskParamsRequest, O: QueryAllCollateralRiskParamsResponse },
    { name: "AllBackingPools", options: { "google.api.http": { get: "/merlion/maker/v1/all_backing_pools" } }, I: QueryAllBackingPoolsRequest, O: QueryAllBackingPoolsResponse },
    { name: "AllCollateralPools", options: { "google.api.http": { get: "/merlion/maker/v1/all_collateral_pools" } }, I: QueryAllCollateralPoolsRequest, O: QueryAllCollateralPoolsResponse },
    { name: "BackingPool", options: { "google.api.http": { get: "/merlion/maker/v1/backing_pool" } }, I: QueryBackingPoolRequest, O: QueryBackingPoolResponse },
    { name: "CollateralPool", options: { "google.api.http": { get: "/merlion/maker/v1/collateral_pool" } }, I: QueryCollateralPoolRequest, O: QueryCollateralPoolResponse },
    { name: "CollateralOfAccount", options: { "google.api.http": { get: "/merlion/maker/v1/collateral_account" } }, I: QueryCollateralOfAccountRequest, O: QueryCollateralOfAccountResponse },
    { name: "TotalBacking", options: { "google.api.http": { get: "/merlion/maker/v1/total_backing" } }, I: QueryTotalBackingRequest, O: QueryTotalBackingResponse },
    { name: "TotalCollateral", options: { "google.api.http": { get: "/merlion/maker/v1/total_collateral" } }, I: QueryTotalCollateralRequest, O: QueryTotalCollateralResponse },
    { name: "BackingRatio", options: { "google.api.http": { get: "/merlion/maker/v1/backing_ratio" } }, I: QueryBackingRatioRequest, O: QueryBackingRatioResponse },
    { name: "Params", options: { "google.api.http": { get: "/merlion/maker/v1/params" } }, I: QueryParamsRequest, O: QueryParamsResponse },
    { name: "EstimateMintBySwapIn", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_mint_by_swap_in" } }, I: EstimateMintBySwapInRequest, O: EstimateMintBySwapInResponse },
    { name: "EstimateMintBySwapOut", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_mint_by_swap_out" } }, I: EstimateMintBySwapOutRequest, O: EstimateMintBySwapOutResponse },
    { name: "EstimateBurnBySwapIn", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_burn_by_swap_in" } }, I: EstimateBurnBySwapInRequest, O: EstimateBurnBySwapInResponse },
    { name: "EstimateBurnBySwapOut", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_burn_by_swap_out" } }, I: EstimateBurnBySwapOutRequest, O: EstimateBurnBySwapOutResponse },
    { name: "EstimateBuyBackingIn", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_buy_backing_in" } }, I: EstimateBuyBackingInRequest, O: EstimateBuyBackingInResponse },
    { name: "EstimateBuyBackingOut", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_buy_backing_out" } }, I: EstimateBuyBackingOutRequest, O: EstimateBuyBackingOutResponse },
    { name: "EstimateSellBackingIn", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_sell_backing_in" } }, I: EstimateSellBackingInRequest, O: EstimateSellBackingInResponse },
    { name: "EstimateSellBackingOut", options: { "google.api.http": { get: "/merlion/maker/v1/estimate_sell_backing_out" } }, I: EstimateSellBackingOutRequest, O: EstimateSellBackingOutResponse }
]);
