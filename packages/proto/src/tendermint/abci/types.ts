// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "tendermint/abci/types.proto" (package "tendermint.abci", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PublicKey } from "../crypto/keys";
import { VersionParams } from "../types/params";
import { ValidatorParams } from "../types/params";
import { EvidenceParams } from "../types/params";
import { ProofOps } from "../crypto/proof";
import { Header } from "../types/types";
import { Timestamp } from "../../google/protobuf/timestamp";
// This file is copied from http://github.com/tendermint/abci
// NOTE: When using custom types, mind the warnings.
// https://github.com/gogo/protobuf/blob/master/custom_types.md#warnings-and-issues

// ----------------------------------------
// Request types

/**
 * @generated from protobuf message tendermint.abci.Request
 */
export interface Request {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "echo";
        /**
         * @generated from protobuf field: tendermint.abci.RequestEcho echo = 1;
         */
        echo: RequestEcho;
    } | {
        oneofKind: "flush";
        /**
         * @generated from protobuf field: tendermint.abci.RequestFlush flush = 2;
         */
        flush: RequestFlush;
    } | {
        oneofKind: "info";
        /**
         * @generated from protobuf field: tendermint.abci.RequestInfo info = 3;
         */
        info: RequestInfo;
    } | {
        oneofKind: "setOption";
        /**
         * @generated from protobuf field: tendermint.abci.RequestSetOption set_option = 4;
         */
        setOption: RequestSetOption;
    } | {
        oneofKind: "initChain";
        /**
         * @generated from protobuf field: tendermint.abci.RequestInitChain init_chain = 5;
         */
        initChain: RequestInitChain;
    } | {
        oneofKind: "query";
        /**
         * @generated from protobuf field: tendermint.abci.RequestQuery query = 6;
         */
        query: RequestQuery;
    } | {
        oneofKind: "beginBlock";
        /**
         * @generated from protobuf field: tendermint.abci.RequestBeginBlock begin_block = 7;
         */
        beginBlock: RequestBeginBlock;
    } | {
        oneofKind: "checkTx";
        /**
         * @generated from protobuf field: tendermint.abci.RequestCheckTx check_tx = 8;
         */
        checkTx: RequestCheckTx;
    } | {
        oneofKind: "deliverTx";
        /**
         * @generated from protobuf field: tendermint.abci.RequestDeliverTx deliver_tx = 9;
         */
        deliverTx: RequestDeliverTx;
    } | {
        oneofKind: "endBlock";
        /**
         * @generated from protobuf field: tendermint.abci.RequestEndBlock end_block = 10;
         */
        endBlock: RequestEndBlock;
    } | {
        oneofKind: "commit";
        /**
         * @generated from protobuf field: tendermint.abci.RequestCommit commit = 11;
         */
        commit: RequestCommit;
    } | {
        oneofKind: "listSnapshots";
        /**
         * @generated from protobuf field: tendermint.abci.RequestListSnapshots list_snapshots = 12;
         */
        listSnapshots: RequestListSnapshots;
    } | {
        oneofKind: "offerSnapshot";
        /**
         * @generated from protobuf field: tendermint.abci.RequestOfferSnapshot offer_snapshot = 13;
         */
        offerSnapshot: RequestOfferSnapshot;
    } | {
        oneofKind: "loadSnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14;
         */
        loadSnapshotChunk: RequestLoadSnapshotChunk;
    } | {
        oneofKind: "applySnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15;
         */
        applySnapshotChunk: RequestApplySnapshotChunk;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message tendermint.abci.RequestEcho
 */
export interface RequestEcho {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message tendermint.abci.RequestFlush
 */
export interface RequestFlush {
}
/**
 * @generated from protobuf message tendermint.abci.RequestInfo
 */
export interface RequestInfo {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: uint64 block_version = 2;
     */
    blockVersion: string;
    /**
     * @generated from protobuf field: uint64 p2p_version = 3 [json_name = "p2pVersion"];
     */
    p2PVersion: string;
}
/**
 * nondeterministic
 *
 * @generated from protobuf message tendermint.abci.RequestSetOption
 */
export interface RequestSetOption {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message tendermint.abci.RequestInitChain
 */
export interface RequestInitChain {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp time = 1;
     */
    time?: Timestamp;
    /**
     * @generated from protobuf field: string chain_id = 2;
     */
    chainId: string;
    /**
     * @generated from protobuf field: tendermint.abci.ConsensusParams consensus_params = 3;
     */
    consensusParams?: ConsensusParams;
    /**
     * @generated from protobuf field: repeated tendermint.abci.ValidatorUpdate validators = 4;
     */
    validators: ValidatorUpdate[];
    /**
     * @generated from protobuf field: bytes app_state_bytes = 5;
     */
    appStateBytes: Uint8Array;
    /**
     * @generated from protobuf field: int64 initial_height = 6;
     */
    initialHeight: string;
}
/**
 * @generated from protobuf message tendermint.abci.RequestQuery
 */
export interface RequestQuery {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string path = 2;
     */
    path: string;
    /**
     * @generated from protobuf field: int64 height = 3;
     */
    height: string;
    /**
     * @generated from protobuf field: bool prove = 4;
     */
    prove: boolean;
}
/**
 * @generated from protobuf message tendermint.abci.RequestBeginBlock
 */
export interface RequestBeginBlock {
    /**
     * @generated from protobuf field: bytes hash = 1;
     */
    hash: Uint8Array;
    /**
     * @generated from protobuf field: tendermint.types.Header header = 2;
     */
    header?: Header;
    /**
     * @generated from protobuf field: tendermint.abci.LastCommitInfo last_commit_info = 3;
     */
    lastCommitInfo?: LastCommitInfo;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Evidence byzantine_validators = 4;
     */
    byzantineValidators: Evidence[];
}
/**
 * @generated from protobuf message tendermint.abci.RequestCheckTx
 */
export interface RequestCheckTx {
    /**
     * @generated from protobuf field: bytes tx = 1;
     */
    tx: Uint8Array;
    /**
     * @generated from protobuf field: tendermint.abci.CheckTxType type = 2;
     */
    type: CheckTxType;
}
/**
 * @generated from protobuf message tendermint.abci.RequestDeliverTx
 */
export interface RequestDeliverTx {
    /**
     * @generated from protobuf field: bytes tx = 1;
     */
    tx: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.RequestEndBlock
 */
export interface RequestEndBlock {
    /**
     * @generated from protobuf field: int64 height = 1;
     */
    height: string;
}
/**
 * @generated from protobuf message tendermint.abci.RequestCommit
 */
export interface RequestCommit {
}
/**
 * lists available snapshots
 *
 * @generated from protobuf message tendermint.abci.RequestListSnapshots
 */
export interface RequestListSnapshots {
}
/**
 * offers a snapshot to the application
 *
 * @generated from protobuf message tendermint.abci.RequestOfferSnapshot
 */
export interface RequestOfferSnapshot {
    /**
     * @generated from protobuf field: tendermint.abci.Snapshot snapshot = 1;
     */
    snapshot?: Snapshot; // snapshot offered by peers
    /**
     * @generated from protobuf field: bytes app_hash = 2;
     */
    appHash: Uint8Array; // light client-verified app hash for snapshot height
}
/**
 * loads a snapshot chunk
 *
 * @generated from protobuf message tendermint.abci.RequestLoadSnapshotChunk
 */
export interface RequestLoadSnapshotChunk {
    /**
     * @generated from protobuf field: uint64 height = 1;
     */
    height: string;
    /**
     * @generated from protobuf field: uint32 format = 2;
     */
    format: number;
    /**
     * @generated from protobuf field: uint32 chunk = 3;
     */
    chunk: number;
}
/**
 * Applies a snapshot chunk
 *
 * @generated from protobuf message tendermint.abci.RequestApplySnapshotChunk
 */
export interface RequestApplySnapshotChunk {
    /**
     * @generated from protobuf field: uint32 index = 1;
     */
    index: number;
    /**
     * @generated from protobuf field: bytes chunk = 2;
     */
    chunk: Uint8Array;
    /**
     * @generated from protobuf field: string sender = 3;
     */
    sender: string;
}
// ----------------------------------------
// Response types

/**
 * @generated from protobuf message tendermint.abci.Response
 */
export interface Response {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "exception";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseException exception = 1;
         */
        exception: ResponseException;
    } | {
        oneofKind: "echo";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseEcho echo = 2;
         */
        echo: ResponseEcho;
    } | {
        oneofKind: "flush";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseFlush flush = 3;
         */
        flush: ResponseFlush;
    } | {
        oneofKind: "info";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseInfo info = 4;
         */
        info: ResponseInfo;
    } | {
        oneofKind: "setOption";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseSetOption set_option = 5;
         */
        setOption: ResponseSetOption;
    } | {
        oneofKind: "initChain";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseInitChain init_chain = 6;
         */
        initChain: ResponseInitChain;
    } | {
        oneofKind: "query";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseQuery query = 7;
         */
        query: ResponseQuery;
    } | {
        oneofKind: "beginBlock";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseBeginBlock begin_block = 8;
         */
        beginBlock: ResponseBeginBlock;
    } | {
        oneofKind: "checkTx";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseCheckTx check_tx = 9;
         */
        checkTx: ResponseCheckTx;
    } | {
        oneofKind: "deliverTx";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseDeliverTx deliver_tx = 10;
         */
        deliverTx: ResponseDeliverTx;
    } | {
        oneofKind: "endBlock";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseEndBlock end_block = 11;
         */
        endBlock: ResponseEndBlock;
    } | {
        oneofKind: "commit";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseCommit commit = 12;
         */
        commit: ResponseCommit;
    } | {
        oneofKind: "listSnapshots";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseListSnapshots list_snapshots = 13;
         */
        listSnapshots: ResponseListSnapshots;
    } | {
        oneofKind: "offerSnapshot";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14;
         */
        offerSnapshot: ResponseOfferSnapshot;
    } | {
        oneofKind: "loadSnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15;
         */
        loadSnapshotChunk: ResponseLoadSnapshotChunk;
    } | {
        oneofKind: "applySnapshotChunk";
        /**
         * @generated from protobuf field: tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16;
         */
        applySnapshotChunk: ResponseApplySnapshotChunk;
    } | {
        oneofKind: undefined;
    };
}
/**
 * nondeterministic
 *
 * @generated from protobuf message tendermint.abci.ResponseException
 */
export interface ResponseException {
    /**
     * @generated from protobuf field: string error = 1;
     */
    error: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseEcho
 */
export interface ResponseEcho {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseFlush
 */
export interface ResponseFlush {
}
/**
 * @generated from protobuf message tendermint.abci.ResponseInfo
 */
export interface ResponseInfo {
    /**
     * @generated from protobuf field: string data = 1;
     */
    data: string;
    /**
     * @generated from protobuf field: string version = 2;
     */
    version: string;
    /**
     * @generated from protobuf field: uint64 app_version = 3;
     */
    appVersion: string;
    /**
     * @generated from protobuf field: int64 last_block_height = 4;
     */
    lastBlockHeight: string;
    /**
     * @generated from protobuf field: bytes last_block_app_hash = 5;
     */
    lastBlockAppHash: Uint8Array;
}
/**
 * nondeterministic
 *
 * @generated from protobuf message tendermint.abci.ResponseSetOption
 */
export interface ResponseSetOption {
    /**
     * @generated from protobuf field: uint32 code = 1;
     */
    code: number;
    /**
     * bytes data = 2;
     *
     * @generated from protobuf field: string log = 3;
     */
    log: string;
    /**
     * @generated from protobuf field: string info = 4;
     */
    info: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseInitChain
 */
export interface ResponseInitChain {
    /**
     * @generated from protobuf field: tendermint.abci.ConsensusParams consensus_params = 1;
     */
    consensusParams?: ConsensusParams;
    /**
     * @generated from protobuf field: repeated tendermint.abci.ValidatorUpdate validators = 2;
     */
    validators: ValidatorUpdate[];
    /**
     * @generated from protobuf field: bytes app_hash = 3;
     */
    appHash: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseQuery
 */
export interface ResponseQuery {
    /**
     * @generated from protobuf field: uint32 code = 1;
     */
    code: number;
    /**
     * bytes data = 2; // use "value" instead.
     *
     * @generated from protobuf field: string log = 3;
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4;
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 index = 5;
     */
    index: string;
    /**
     * @generated from protobuf field: bytes key = 6;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 7;
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: tendermint.crypto.ProofOps proof_ops = 8;
     */
    proofOps?: ProofOps;
    /**
     * @generated from protobuf field: int64 height = 9;
     */
    height: string;
    /**
     * @generated from protobuf field: string codespace = 10;
     */
    codespace: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseBeginBlock
 */
export interface ResponseBeginBlock {
    /**
     * @generated from protobuf field: repeated tendermint.abci.Event events = 1;
     */
    events: Event[];
}
/**
 * @generated from protobuf message tendermint.abci.ResponseCheckTx
 */
export interface ResponseCheckTx {
    /**
     * @generated from protobuf field: uint32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string log = 3;
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4;
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 gas_wanted = 5 [json_name = "gas_wanted"];
     */
    gasWanted: string;
    /**
     * @generated from protobuf field: int64 gas_used = 6 [json_name = "gas_used"];
     */
    gasUsed: string;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Event events = 7;
     */
    events: Event[];
    /**
     * @generated from protobuf field: string codespace = 8;
     */
    codespace: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseDeliverTx
 */
export interface ResponseDeliverTx {
    /**
     * @generated from protobuf field: uint32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: string log = 3;
     */
    log: string; // nondeterministic
    /**
     * @generated from protobuf field: string info = 4;
     */
    info: string; // nondeterministic
    /**
     * @generated from protobuf field: int64 gas_wanted = 5 [json_name = "gas_wanted"];
     */
    gasWanted: string;
    /**
     * @generated from protobuf field: int64 gas_used = 6 [json_name = "gas_used"];
     */
    gasUsed: string;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Event events = 7;
     */
    events: Event[]; // nondeterministic
    /**
     * @generated from protobuf field: string codespace = 8;
     */
    codespace: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseEndBlock
 */
export interface ResponseEndBlock {
    /**
     * @generated from protobuf field: repeated tendermint.abci.ValidatorUpdate validator_updates = 1;
     */
    validatorUpdates: ValidatorUpdate[];
    /**
     * @generated from protobuf field: tendermint.abci.ConsensusParams consensus_param_updates = 2;
     */
    consensusParamUpdates?: ConsensusParams;
    /**
     * @generated from protobuf field: repeated tendermint.abci.Event events = 3;
     */
    events: Event[];
}
/**
 * @generated from protobuf message tendermint.abci.ResponseCommit
 */
export interface ResponseCommit {
    /**
     * reserve 1
     *
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: int64 retain_height = 3;
     */
    retainHeight: string;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseListSnapshots
 */
export interface ResponseListSnapshots {
    /**
     * @generated from protobuf field: repeated tendermint.abci.Snapshot snapshots = 1;
     */
    snapshots: Snapshot[];
}
/**
 * @generated from protobuf message tendermint.abci.ResponseOfferSnapshot
 */
export interface ResponseOfferSnapshot {
    /**
     * @generated from protobuf field: tendermint.abci.ResponseOfferSnapshot.Result result = 1;
     */
    result: ResponseOfferSnapshot_Result;
}
/**
 * @generated from protobuf enum tendermint.abci.ResponseOfferSnapshot.Result
 */
export enum ResponseOfferSnapshot_Result {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Snapshot accepted, apply chunks
     *
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: ABORT = 2;
     */
    ABORT = 2,
    /**
     * Reject this specific snapshot, try others
     *
     * @generated from protobuf enum value: REJECT = 3;
     */
    REJECT = 3,
    /**
     * Reject all snapshots of this format, try others
     *
     * @generated from protobuf enum value: REJECT_FORMAT = 4;
     */
    REJECT_FORMAT = 4,
    /**
     * Reject all snapshots from the sender(s), try others
     *
     * @generated from protobuf enum value: REJECT_SENDER = 5;
     */
    REJECT_SENDER = 5
}
/**
 * @generated from protobuf message tendermint.abci.ResponseLoadSnapshotChunk
 */
export interface ResponseLoadSnapshotChunk {
    /**
     * @generated from protobuf field: bytes chunk = 1;
     */
    chunk: Uint8Array;
}
/**
 * @generated from protobuf message tendermint.abci.ResponseApplySnapshotChunk
 */
export interface ResponseApplySnapshotChunk {
    /**
     * @generated from protobuf field: tendermint.abci.ResponseApplySnapshotChunk.Result result = 1;
     */
    result: ResponseApplySnapshotChunk_Result;
    /**
     * @generated from protobuf field: repeated uint32 refetch_chunks = 2;
     */
    refetchChunks: number[]; // Chunks to refetch and reapply
    /**
     * @generated from protobuf field: repeated string reject_senders = 3;
     */
    rejectSenders: string[]; // Chunk senders to reject and ban
}
/**
 * @generated from protobuf enum tendermint.abci.ResponseApplySnapshotChunk.Result
 */
export enum ResponseApplySnapshotChunk_Result {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Chunk successfully accepted
     *
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ACCEPT = 1,
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: ABORT = 2;
     */
    ABORT = 2,
    /**
     * Retry chunk (combine with refetch and reject)
     *
     * @generated from protobuf enum value: RETRY = 3;
     */
    RETRY = 3,
    /**
     * Retry snapshot (combine with refetch and reject)
     *
     * @generated from protobuf enum value: RETRY_SNAPSHOT = 4;
     */
    RETRY_SNAPSHOT = 4,
    /**
     * Reject this snapshot, try others
     *
     * @generated from protobuf enum value: REJECT_SNAPSHOT = 5;
     */
    REJECT_SNAPSHOT = 5
}
// ----------------------------------------
// Misc.

/**
 * ConsensusParams contains all consensus-relevant parameters
 * that can be adjusted by the abci app
 *
 * @generated from protobuf message tendermint.abci.ConsensusParams
 */
export interface ConsensusParams {
    /**
     * @generated from protobuf field: tendermint.abci.BlockParams block = 1;
     */
    block?: BlockParams;
    /**
     * @generated from protobuf field: tendermint.types.EvidenceParams evidence = 2;
     */
    evidence?: EvidenceParams;
    /**
     * @generated from protobuf field: tendermint.types.ValidatorParams validator = 3;
     */
    validator?: ValidatorParams;
    /**
     * @generated from protobuf field: tendermint.types.VersionParams version = 4;
     */
    version?: VersionParams;
}
/**
 * BlockParams contains limits on the block size.
 *
 * @generated from protobuf message tendermint.abci.BlockParams
 */
export interface BlockParams {
    /**
     * Note: must be greater than 0
     *
     * @generated from protobuf field: int64 max_bytes = 1;
     */
    maxBytes: string;
    /**
     * Note: must be greater or equal to -1
     *
     * @generated from protobuf field: int64 max_gas = 2;
     */
    maxGas: string;
}
/**
 * @generated from protobuf message tendermint.abci.LastCommitInfo
 */
export interface LastCommitInfo {
    /**
     * @generated from protobuf field: int32 round = 1;
     */
    round: number;
    /**
     * @generated from protobuf field: repeated tendermint.abci.VoteInfo votes = 2;
     */
    votes: VoteInfo[];
}
/**
 * Event allows application developers to attach additional information to
 * ResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.
 * Later, transactions may be queried using these events.
 *
 * @generated from protobuf message tendermint.abci.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: repeated tendermint.abci.EventAttribute attributes = 2;
     */
    attributes: EventAttribute[];
}
/**
 * EventAttribute is a single key-value pair, associated with an event.
 *
 * @generated from protobuf message tendermint.abci.EventAttribute
 */
export interface EventAttribute {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: bool index = 3;
     */
    index: boolean; // nondeterministic
}
/**
 * TxResult contains results of executing the transaction.
 *
 * One usage is indexing transaction results.
 *
 * @generated from protobuf message tendermint.abci.TxResult
 */
export interface TxResult {
    /**
     * @generated from protobuf field: int64 height = 1;
     */
    height: string;
    /**
     * @generated from protobuf field: uint32 index = 2;
     */
    index: number;
    /**
     * @generated from protobuf field: bytes tx = 3;
     */
    tx: Uint8Array;
    /**
     * @generated from protobuf field: tendermint.abci.ResponseDeliverTx result = 4;
     */
    result?: ResponseDeliverTx;
}
// ----------------------------------------
// Blockchain Types

/**
 * Validator
 *
 * @generated from protobuf message tendermint.abci.Validator
 */
export interface Validator {
    /**
     * @generated from protobuf field: bytes address = 1;
     */
    address: Uint8Array; // The first 20 bytes of SHA256(public key)
    /**
     * PubKey pub_key = 2 [(gogoproto.nullable)=false];
     *
     * @generated from protobuf field: int64 power = 3;
     */
    power: string; // The voting power
}
/**
 * ValidatorUpdate
 *
 * @generated from protobuf message tendermint.abci.ValidatorUpdate
 */
export interface ValidatorUpdate {
    /**
     * @generated from protobuf field: tendermint.crypto.PublicKey pub_key = 1;
     */
    pubKey?: PublicKey;
    /**
     * @generated from protobuf field: int64 power = 2;
     */
    power: string;
}
/**
 * VoteInfo
 *
 * @generated from protobuf message tendermint.abci.VoteInfo
 */
export interface VoteInfo {
    /**
     * @generated from protobuf field: tendermint.abci.Validator validator = 1;
     */
    validator?: Validator;
    /**
     * @generated from protobuf field: bool signed_last_block = 2;
     */
    signedLastBlock: boolean;
}
/**
 * @generated from protobuf message tendermint.abci.Evidence
 */
export interface Evidence {
    /**
     * @generated from protobuf field: tendermint.abci.EvidenceType type = 1;
     */
    type: EvidenceType;
    /**
     * The offending validator
     *
     * @generated from protobuf field: tendermint.abci.Validator validator = 2;
     */
    validator?: Validator;
    /**
     * The height when the offense occurred
     *
     * @generated from protobuf field: int64 height = 3;
     */
    height: string;
    /**
     * The corresponding time where the offense occurred
     *
     * @generated from protobuf field: google.protobuf.Timestamp time = 4;
     */
    time?: Timestamp;
    /**
     * Total voting power of the validator set in case the ABCI application does
     * not store historical validators.
     * https://github.com/tendermint/tendermint/issues/4581
     *
     * @generated from protobuf field: int64 total_voting_power = 5;
     */
    totalVotingPower: string;
}
// ----------------------------------------
// State Sync Types

/**
 * @generated from protobuf message tendermint.abci.Snapshot
 */
export interface Snapshot {
    /**
     * @generated from protobuf field: uint64 height = 1;
     */
    height: string; // The height at which the snapshot was taken
    /**
     * @generated from protobuf field: uint32 format = 2;
     */
    format: number; // The application-specific snapshot format
    /**
     * @generated from protobuf field: uint32 chunks = 3;
     */
    chunks: number; // Number of chunks in the snapshot
    /**
     * @generated from protobuf field: bytes hash = 4;
     */
    hash: Uint8Array; // Arbitrary snapshot hash, equal only if identical
    /**
     * @generated from protobuf field: bytes metadata = 5;
     */
    metadata: Uint8Array; // Arbitrary application metadata
}
/**
 * @generated from protobuf enum tendermint.abci.CheckTxType
 */
export enum CheckTxType {
    /**
     * @generated from protobuf enum value: NEW = 0;
     */
    NEW = 0,
    /**
     * @generated from protobuf enum value: RECHECK = 1;
     */
    RECHECK = 1
}
/**
 * @generated from protobuf enum tendermint.abci.EvidenceType
 */
export enum EvidenceType {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: DUPLICATE_VOTE = 1;
     */
    DUPLICATE_VOTE = 1,
    /**
     * @generated from protobuf enum value: LIGHT_CLIENT_ATTACK = 2;
     */
    LIGHT_CLIENT_ATTACK = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Request$Type extends MessageType<Request> {
    constructor() {
        super("tendermint.abci.Request", [
            { no: 1, name: "echo", kind: "message", oneof: "value", T: () => RequestEcho },
            { no: 2, name: "flush", kind: "message", oneof: "value", T: () => RequestFlush },
            { no: 3, name: "info", kind: "message", oneof: "value", T: () => RequestInfo },
            { no: 4, name: "set_option", kind: "message", oneof: "value", T: () => RequestSetOption },
            { no: 5, name: "init_chain", kind: "message", oneof: "value", T: () => RequestInitChain },
            { no: 6, name: "query", kind: "message", oneof: "value", T: () => RequestQuery },
            { no: 7, name: "begin_block", kind: "message", oneof: "value", T: () => RequestBeginBlock },
            { no: 8, name: "check_tx", kind: "message", oneof: "value", T: () => RequestCheckTx },
            { no: 9, name: "deliver_tx", kind: "message", oneof: "value", T: () => RequestDeliverTx },
            { no: 10, name: "end_block", kind: "message", oneof: "value", T: () => RequestEndBlock },
            { no: 11, name: "commit", kind: "message", oneof: "value", T: () => RequestCommit },
            { no: 12, name: "list_snapshots", kind: "message", oneof: "value", T: () => RequestListSnapshots },
            { no: 13, name: "offer_snapshot", kind: "message", oneof: "value", T: () => RequestOfferSnapshot },
            { no: 14, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestLoadSnapshotChunk },
            { no: 15, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestApplySnapshotChunk }
        ]);
    }
    create(value?: PartialMessage<Request>): Request {
        const message = { value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Request): Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.RequestEcho echo */ 1:
                    message.value = {
                        oneofKind: "echo",
                        echo: RequestEcho.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).echo)
                    };
                    break;
                case /* tendermint.abci.RequestFlush flush */ 2:
                    message.value = {
                        oneofKind: "flush",
                        flush: RequestFlush.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).flush)
                    };
                    break;
                case /* tendermint.abci.RequestInfo info */ 3:
                    message.value = {
                        oneofKind: "info",
                        info: RequestInfo.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).info)
                    };
                    break;
                case /* tendermint.abci.RequestSetOption set_option */ 4:
                    message.value = {
                        oneofKind: "setOption",
                        setOption: RequestSetOption.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).setOption)
                    };
                    break;
                case /* tendermint.abci.RequestInitChain init_chain */ 5:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: RequestInitChain.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).initChain)
                    };
                    break;
                case /* tendermint.abci.RequestQuery query */ 6:
                    message.value = {
                        oneofKind: "query",
                        query: RequestQuery.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).query)
                    };
                    break;
                case /* tendermint.abci.RequestBeginBlock begin_block */ 7:
                    message.value = {
                        oneofKind: "beginBlock",
                        beginBlock: RequestBeginBlock.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).beginBlock)
                    };
                    break;
                case /* tendermint.abci.RequestCheckTx check_tx */ 8:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: RequestCheckTx.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).checkTx)
                    };
                    break;
                case /* tendermint.abci.RequestDeliverTx deliver_tx */ 9:
                    message.value = {
                        oneofKind: "deliverTx",
                        deliverTx: RequestDeliverTx.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).deliverTx)
                    };
                    break;
                case /* tendermint.abci.RequestEndBlock end_block */ 10:
                    message.value = {
                        oneofKind: "endBlock",
                        endBlock: RequestEndBlock.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).endBlock)
                    };
                    break;
                case /* tendermint.abci.RequestCommit commit */ 11:
                    message.value = {
                        oneofKind: "commit",
                        commit: RequestCommit.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).commit)
                    };
                    break;
                case /* tendermint.abci.RequestListSnapshots list_snapshots */ 12:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: RequestListSnapshots.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).listSnapshots)
                    };
                    break;
                case /* tendermint.abci.RequestOfferSnapshot offer_snapshot */ 13:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: RequestOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).offerSnapshot)
                    };
                    break;
                case /* tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk */ 14:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: RequestLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).loadSnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: RequestApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).applySnapshotChunk)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.RequestEcho echo = 1; */
        if (message.value.oneofKind === "echo")
            RequestEcho.internalBinaryWrite(message.value.echo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestFlush flush = 2; */
        if (message.value.oneofKind === "flush")
            RequestFlush.internalBinaryWrite(message.value.flush, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestInfo info = 3; */
        if (message.value.oneofKind === "info")
            RequestInfo.internalBinaryWrite(message.value.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestSetOption set_option = 4; */
        if (message.value.oneofKind === "setOption")
            RequestSetOption.internalBinaryWrite(message.value.setOption, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestInitChain init_chain = 5; */
        if (message.value.oneofKind === "initChain")
            RequestInitChain.internalBinaryWrite(message.value.initChain, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestQuery query = 6; */
        if (message.value.oneofKind === "query")
            RequestQuery.internalBinaryWrite(message.value.query, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestBeginBlock begin_block = 7; */
        if (message.value.oneofKind === "beginBlock")
            RequestBeginBlock.internalBinaryWrite(message.value.beginBlock, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestCheckTx check_tx = 8; */
        if (message.value.oneofKind === "checkTx")
            RequestCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestDeliverTx deliver_tx = 9; */
        if (message.value.oneofKind === "deliverTx")
            RequestDeliverTx.internalBinaryWrite(message.value.deliverTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestEndBlock end_block = 10; */
        if (message.value.oneofKind === "endBlock")
            RequestEndBlock.internalBinaryWrite(message.value.endBlock, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestCommit commit = 11; */
        if (message.value.oneofKind === "commit")
            RequestCommit.internalBinaryWrite(message.value.commit, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestListSnapshots list_snapshots = 12; */
        if (message.value.oneofKind === "listSnapshots")
            RequestListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestOfferSnapshot offer_snapshot = 13; */
        if (message.value.oneofKind === "offerSnapshot")
            RequestOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            RequestLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15; */
        if (message.value.oneofKind === "applySnapshotChunk")
            RequestApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Request
 */
export const Request = new Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestEcho$Type extends MessageType<RequestEcho> {
    constructor() {
        super("tendermint.abci.RequestEcho", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestEcho>): RequestEcho {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestEcho>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestEcho): RequestEcho {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestEcho, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestEcho
 */
export const RequestEcho = new RequestEcho$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestFlush$Type extends MessageType<RequestFlush> {
    constructor() {
        super("tendermint.abci.RequestFlush", []);
    }
    create(value?: PartialMessage<RequestFlush>): RequestFlush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestFlush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestFlush): RequestFlush {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RequestFlush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestFlush
 */
export const RequestFlush = new RequestFlush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestInfo$Type extends MessageType<RequestInfo> {
    constructor() {
        super("tendermint.abci.RequestInfo", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "p2p_version", kind: "scalar", jsonName: "p2pVersion", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<RequestInfo>): RequestInfo {
        const message = { version: "", blockVersion: "0", p2PVersion: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestInfo): RequestInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* uint64 block_version */ 2:
                    message.blockVersion = reader.uint64().toString();
                    break;
                case /* uint64 p2p_version = 3 [json_name = "p2pVersion"];*/ 3:
                    message.p2PVersion = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* uint64 block_version = 2; */
        if (message.blockVersion !== "0")
            writer.tag(2, WireType.Varint).uint64(message.blockVersion);
        /* uint64 p2p_version = 3 [json_name = "p2pVersion"]; */
        if (message.p2PVersion !== "0")
            writer.tag(3, WireType.Varint).uint64(message.p2PVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestInfo
 */
export const RequestInfo = new RequestInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestSetOption$Type extends MessageType<RequestSetOption> {
    constructor() {
        super("tendermint.abci.RequestSetOption", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestSetOption>): RequestSetOption {
        const message = { key: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestSetOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestSetOption): RequestSetOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestSetOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestSetOption
 */
export const RequestSetOption = new RequestSetOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestInitChain$Type extends MessageType<RequestInitChain> {
    constructor() {
        super("tendermint.abci.RequestInitChain", [
            { no: 1, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 2, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 4, name: "validators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 5, name: "app_state_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "initial_height", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<RequestInitChain>): RequestInitChain {
        const message = { chainId: "", validators: [], appStateBytes: new Uint8Array(0), initialHeight: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestInitChain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestInitChain): RequestInitChain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp time */ 1:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string chain_id */ 2:
                    message.chainId = reader.string();
                    break;
                case /* tendermint.abci.ConsensusParams consensus_params */ 3:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated tendermint.abci.ValidatorUpdate validators */ 4:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_state_bytes */ 5:
                    message.appStateBytes = reader.bytes();
                    break;
                case /* int64 initial_height */ 6:
                    message.initialHeight = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestInitChain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp time = 1; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string chain_id = 2; */
        if (message.chainId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chainId);
        /* tendermint.abci.ConsensusParams consensus_params = 3; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ValidatorUpdate validators = 4; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_state_bytes = 5; */
        if (message.appStateBytes.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.appStateBytes);
        /* int64 initial_height = 6; */
        if (message.initialHeight !== "0")
            writer.tag(6, WireType.Varint).int64(message.initialHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestInitChain
 */
export const RequestInitChain = new RequestInitChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestQuery$Type extends MessageType<RequestQuery> {
    constructor() {
        super("tendermint.abci.RequestQuery", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "prove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RequestQuery>): RequestQuery {
        const message = { data: new Uint8Array(0), path: "", height: "0", prove: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestQuery): RequestQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toString();
                    break;
                case /* bool prove */ 4:
                    message.prove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* int64 height = 3; */
        if (message.height !== "0")
            writer.tag(3, WireType.Varint).int64(message.height);
        /* bool prove = 4; */
        if (message.prove !== false)
            writer.tag(4, WireType.Varint).bool(message.prove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestQuery
 */
export const RequestQuery = new RequestQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestBeginBlock$Type extends MessageType<RequestBeginBlock> {
    constructor() {
        super("tendermint.abci.RequestBeginBlock", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "header", kind: "message", T: () => Header, options: { "gogoproto.nullable": false } },
            { no: 3, name: "last_commit_info", kind: "message", T: () => LastCommitInfo, options: { "gogoproto.nullable": false } },
            { no: 4, name: "byzantine_validators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Evidence, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<RequestBeginBlock>): RequestBeginBlock {
        const message = { hash: new Uint8Array(0), byzantineValidators: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestBeginBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestBeginBlock): RequestBeginBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* tendermint.types.Header header */ 2:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* tendermint.abci.LastCommitInfo last_commit_info */ 3:
                    message.lastCommitInfo = LastCommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.lastCommitInfo);
                    break;
                case /* repeated tendermint.abci.Evidence byzantine_validators */ 4:
                    message.byzantineValidators.push(Evidence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestBeginBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* tendermint.types.Header header = 2; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.LastCommitInfo last_commit_info = 3; */
        if (message.lastCommitInfo)
            LastCommitInfo.internalBinaryWrite(message.lastCommitInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Evidence byzantine_validators = 4; */
        for (let i = 0; i < message.byzantineValidators.length; i++)
            Evidence.internalBinaryWrite(message.byzantineValidators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestBeginBlock
 */
export const RequestBeginBlock = new RequestBeginBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestCheckTx$Type extends MessageType<RequestCheckTx> {
    constructor() {
        super("tendermint.abci.RequestCheckTx", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["tendermint.abci.CheckTxType", CheckTxType] }
        ]);
    }
    create(value?: PartialMessage<RequestCheckTx>): RequestCheckTx {
        const message = { tx: new Uint8Array(0), type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestCheckTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestCheckTx): RequestCheckTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                case /* tendermint.abci.CheckTxType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestCheckTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        /* tendermint.abci.CheckTxType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestCheckTx
 */
export const RequestCheckTx = new RequestCheckTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestDeliverTx$Type extends MessageType<RequestDeliverTx> {
    constructor() {
        super("tendermint.abci.RequestDeliverTx", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestDeliverTx>): RequestDeliverTx {
        const message = { tx: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestDeliverTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestDeliverTx): RequestDeliverTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestDeliverTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestDeliverTx
 */
export const RequestDeliverTx = new RequestDeliverTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestEndBlock$Type extends MessageType<RequestEndBlock> {
    constructor() {
        super("tendermint.abci.RequestEndBlock", [
            { no: 1, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<RequestEndBlock>): RequestEndBlock {
        const message = { height: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestEndBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestEndBlock): RequestEndBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 height */ 1:
                    message.height = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestEndBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).int64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestEndBlock
 */
export const RequestEndBlock = new RequestEndBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestCommit$Type extends MessageType<RequestCommit> {
    constructor() {
        super("tendermint.abci.RequestCommit", []);
    }
    create(value?: PartialMessage<RequestCommit>): RequestCommit {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestCommit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestCommit): RequestCommit {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RequestCommit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestCommit
 */
export const RequestCommit = new RequestCommit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestListSnapshots$Type extends MessageType<RequestListSnapshots> {
    constructor() {
        super("tendermint.abci.RequestListSnapshots", []);
    }
    create(value?: PartialMessage<RequestListSnapshots>): RequestListSnapshots {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestListSnapshots>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestListSnapshots): RequestListSnapshots {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RequestListSnapshots, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestListSnapshots
 */
export const RequestListSnapshots = new RequestListSnapshots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestOfferSnapshot$Type extends MessageType<RequestOfferSnapshot> {
    constructor() {
        super("tendermint.abci.RequestOfferSnapshot", [
            { no: 1, name: "snapshot", kind: "message", T: () => Snapshot },
            { no: 2, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RequestOfferSnapshot>): RequestOfferSnapshot {
        const message = { appHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestOfferSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestOfferSnapshot): RequestOfferSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.Snapshot snapshot */ 1:
                    message.snapshot = Snapshot.internalBinaryRead(reader, reader.uint32(), options, message.snapshot);
                    break;
                case /* bytes app_hash */ 2:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestOfferSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.Snapshot snapshot = 1; */
        if (message.snapshot)
            Snapshot.internalBinaryWrite(message.snapshot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 2; */
        if (message.appHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestOfferSnapshot
 */
export const RequestOfferSnapshot = new RequestOfferSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestLoadSnapshotChunk$Type extends MessageType<RequestLoadSnapshotChunk> {
    constructor() {
        super("tendermint.abci.RequestLoadSnapshotChunk", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunk", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RequestLoadSnapshotChunk>): RequestLoadSnapshotChunk {
        const message = { height: "0", format: 0, chunk: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestLoadSnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestLoadSnapshotChunk): RequestLoadSnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toString();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunk */ 3:
                    message.chunk = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestLoadSnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunk = 3; */
        if (message.chunk !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestLoadSnapshotChunk
 */
export const RequestLoadSnapshotChunk = new RequestLoadSnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestApplySnapshotChunk$Type extends MessageType<RequestApplySnapshotChunk> {
    constructor() {
        super("tendermint.abci.RequestApplySnapshotChunk", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestApplySnapshotChunk>): RequestApplySnapshotChunk {
        const message = { index: 0, chunk: new Uint8Array(0), sender: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestApplySnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestApplySnapshotChunk): RequestApplySnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* bytes chunk */ 2:
                    message.chunk = reader.bytes();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestApplySnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).uint32(message.index);
        /* bytes chunk = 2; */
        if (message.chunk.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chunk);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestApplySnapshotChunk
 */
export const RequestApplySnapshotChunk = new RequestApplySnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType<Response> {
    constructor() {
        super("tendermint.abci.Response", [
            { no: 1, name: "exception", kind: "message", oneof: "value", T: () => ResponseException },
            { no: 2, name: "echo", kind: "message", oneof: "value", T: () => ResponseEcho },
            { no: 3, name: "flush", kind: "message", oneof: "value", T: () => ResponseFlush },
            { no: 4, name: "info", kind: "message", oneof: "value", T: () => ResponseInfo },
            { no: 5, name: "set_option", kind: "message", oneof: "value", T: () => ResponseSetOption },
            { no: 6, name: "init_chain", kind: "message", oneof: "value", T: () => ResponseInitChain },
            { no: 7, name: "query", kind: "message", oneof: "value", T: () => ResponseQuery },
            { no: 8, name: "begin_block", kind: "message", oneof: "value", T: () => ResponseBeginBlock },
            { no: 9, name: "check_tx", kind: "message", oneof: "value", T: () => ResponseCheckTx },
            { no: 10, name: "deliver_tx", kind: "message", oneof: "value", T: () => ResponseDeliverTx },
            { no: 11, name: "end_block", kind: "message", oneof: "value", T: () => ResponseEndBlock },
            { no: 12, name: "commit", kind: "message", oneof: "value", T: () => ResponseCommit },
            { no: 13, name: "list_snapshots", kind: "message", oneof: "value", T: () => ResponseListSnapshots },
            { no: 14, name: "offer_snapshot", kind: "message", oneof: "value", T: () => ResponseOfferSnapshot },
            { no: 15, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseLoadSnapshotChunk },
            { no: 16, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseApplySnapshotChunk }
        ]);
    }
    create(value?: PartialMessage<Response>): Response {
        const message = { value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Response): Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseException exception */ 1:
                    message.value = {
                        oneofKind: "exception",
                        exception: ResponseException.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).exception)
                    };
                    break;
                case /* tendermint.abci.ResponseEcho echo */ 2:
                    message.value = {
                        oneofKind: "echo",
                        echo: ResponseEcho.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).echo)
                    };
                    break;
                case /* tendermint.abci.ResponseFlush flush */ 3:
                    message.value = {
                        oneofKind: "flush",
                        flush: ResponseFlush.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).flush)
                    };
                    break;
                case /* tendermint.abci.ResponseInfo info */ 4:
                    message.value = {
                        oneofKind: "info",
                        info: ResponseInfo.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).info)
                    };
                    break;
                case /* tendermint.abci.ResponseSetOption set_option */ 5:
                    message.value = {
                        oneofKind: "setOption",
                        setOption: ResponseSetOption.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).setOption)
                    };
                    break;
                case /* tendermint.abci.ResponseInitChain init_chain */ 6:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: ResponseInitChain.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).initChain)
                    };
                    break;
                case /* tendermint.abci.ResponseQuery query */ 7:
                    message.value = {
                        oneofKind: "query",
                        query: ResponseQuery.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).query)
                    };
                    break;
                case /* tendermint.abci.ResponseBeginBlock begin_block */ 8:
                    message.value = {
                        oneofKind: "beginBlock",
                        beginBlock: ResponseBeginBlock.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).beginBlock)
                    };
                    break;
                case /* tendermint.abci.ResponseCheckTx check_tx */ 9:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: ResponseCheckTx.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).checkTx)
                    };
                    break;
                case /* tendermint.abci.ResponseDeliverTx deliver_tx */ 10:
                    message.value = {
                        oneofKind: "deliverTx",
                        deliverTx: ResponseDeliverTx.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).deliverTx)
                    };
                    break;
                case /* tendermint.abci.ResponseEndBlock end_block */ 11:
                    message.value = {
                        oneofKind: "endBlock",
                        endBlock: ResponseEndBlock.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).endBlock)
                    };
                    break;
                case /* tendermint.abci.ResponseCommit commit */ 12:
                    message.value = {
                        oneofKind: "commit",
                        commit: ResponseCommit.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).commit)
                    };
                    break;
                case /* tendermint.abci.ResponseListSnapshots list_snapshots */ 13:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: ResponseListSnapshots.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).listSnapshots)
                    };
                    break;
                case /* tendermint.abci.ResponseOfferSnapshot offer_snapshot */ 14:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: ResponseOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).offerSnapshot)
                    };
                    break;
                case /* tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: ResponseLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).loadSnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk */ 16:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: ResponseApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).applySnapshotChunk)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseException exception = 1; */
        if (message.value.oneofKind === "exception")
            ResponseException.internalBinaryWrite(message.value.exception, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseEcho echo = 2; */
        if (message.value.oneofKind === "echo")
            ResponseEcho.internalBinaryWrite(message.value.echo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseFlush flush = 3; */
        if (message.value.oneofKind === "flush")
            ResponseFlush.internalBinaryWrite(message.value.flush, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseInfo info = 4; */
        if (message.value.oneofKind === "info")
            ResponseInfo.internalBinaryWrite(message.value.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseSetOption set_option = 5; */
        if (message.value.oneofKind === "setOption")
            ResponseSetOption.internalBinaryWrite(message.value.setOption, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseInitChain init_chain = 6; */
        if (message.value.oneofKind === "initChain")
            ResponseInitChain.internalBinaryWrite(message.value.initChain, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseQuery query = 7; */
        if (message.value.oneofKind === "query")
            ResponseQuery.internalBinaryWrite(message.value.query, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseBeginBlock begin_block = 8; */
        if (message.value.oneofKind === "beginBlock")
            ResponseBeginBlock.internalBinaryWrite(message.value.beginBlock, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseCheckTx check_tx = 9; */
        if (message.value.oneofKind === "checkTx")
            ResponseCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseDeliverTx deliver_tx = 10; */
        if (message.value.oneofKind === "deliverTx")
            ResponseDeliverTx.internalBinaryWrite(message.value.deliverTx, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseEndBlock end_block = 11; */
        if (message.value.oneofKind === "endBlock")
            ResponseEndBlock.internalBinaryWrite(message.value.endBlock, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseCommit commit = 12; */
        if (message.value.oneofKind === "commit")
            ResponseCommit.internalBinaryWrite(message.value.commit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseListSnapshots list_snapshots = 13; */
        if (message.value.oneofKind === "listSnapshots")
            ResponseListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14; */
        if (message.value.oneofKind === "offerSnapshot")
            ResponseOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            ResponseLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16; */
        if (message.value.oneofKind === "applySnapshotChunk")
            ResponseApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseException$Type extends MessageType<ResponseException> {
    constructor() {
        super("tendermint.abci.ResponseException", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseException>): ResponseException {
        const message = { error: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseException>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseException): ResponseException {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseException, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseException
 */
export const ResponseException = new ResponseException$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseEcho$Type extends MessageType<ResponseEcho> {
    constructor() {
        super("tendermint.abci.ResponseEcho", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseEcho>): ResponseEcho {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseEcho>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseEcho): ResponseEcho {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseEcho, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseEcho
 */
export const ResponseEcho = new ResponseEcho$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFlush$Type extends MessageType<ResponseFlush> {
    constructor() {
        super("tendermint.abci.ResponseFlush", []);
    }
    create(value?: PartialMessage<ResponseFlush>): ResponseFlush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseFlush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseFlush): ResponseFlush {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResponseFlush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseFlush
 */
export const ResponseFlush = new ResponseFlush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseInfo$Type extends MessageType<ResponseInfo> {
    constructor() {
        super("tendermint.abci.ResponseInfo", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "last_block_height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "last_block_app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseInfo>): ResponseInfo {
        const message = { data: "", version: "", appVersion: "0", lastBlockHeight: "0", lastBlockAppHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseInfo): ResponseInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* uint64 app_version */ 3:
                    message.appVersion = reader.uint64().toString();
                    break;
                case /* int64 last_block_height */ 4:
                    message.lastBlockHeight = reader.int64().toString();
                    break;
                case /* bytes last_block_app_hash */ 5:
                    message.lastBlockAppHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* uint64 app_version = 3; */
        if (message.appVersion !== "0")
            writer.tag(3, WireType.Varint).uint64(message.appVersion);
        /* int64 last_block_height = 4; */
        if (message.lastBlockHeight !== "0")
            writer.tag(4, WireType.Varint).int64(message.lastBlockHeight);
        /* bytes last_block_app_hash = 5; */
        if (message.lastBlockAppHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.lastBlockAppHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseInfo
 */
export const ResponseInfo = new ResponseInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseSetOption$Type extends MessageType<ResponseSetOption> {
    constructor() {
        super("tendermint.abci.ResponseSetOption", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseSetOption>): ResponseSetOption {
        const message = { code: 0, log: "", info: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseSetOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseSetOption): ResponseSetOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseSetOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseSetOption
 */
export const ResponseSetOption = new ResponseSetOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseInitChain$Type extends MessageType<ResponseInitChain> {
    constructor() {
        super("tendermint.abci.ResponseInitChain", [
            { no: 1, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 2, name: "validators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 3, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseInitChain>): ResponseInitChain {
        const message = { validators: [], appHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseInitChain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseInitChain): ResponseInitChain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ConsensusParams consensus_params */ 1:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated tendermint.abci.ValidatorUpdate validators */ 2:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_hash */ 3:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseInitChain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ConsensusParams consensus_params = 1; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ValidatorUpdate validators = 2; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 3; */
        if (message.appHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseInitChain
 */
export const ResponseInitChain = new ResponseInitChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseQuery$Type extends MessageType<ResponseQuery> {
    constructor() {
        super("tendermint.abci.ResponseQuery", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proof_ops", kind: "message", T: () => ProofOps },
            { no: 9, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 10, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseQuery>): ResponseQuery {
        const message = { code: 0, log: "", info: "", index: "0", key: new Uint8Array(0), value: new Uint8Array(0), height: "0", codespace: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseQuery): ResponseQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 index */ 5:
                    message.index = reader.int64().toString();
                    break;
                case /* bytes key */ 6:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 7:
                    message.value = reader.bytes();
                    break;
                case /* tendermint.crypto.ProofOps proof_ops */ 8:
                    message.proofOps = ProofOps.internalBinaryRead(reader, reader.uint32(), options, message.proofOps);
                    break;
                case /* int64 height */ 9:
                    message.height = reader.int64().toString();
                    break;
                case /* string codespace */ 10:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 index = 5; */
        if (message.index !== "0")
            writer.tag(5, WireType.Varint).int64(message.index);
        /* bytes key = 6; */
        if (message.key.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 7; */
        if (message.value.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.value);
        /* tendermint.crypto.ProofOps proof_ops = 8; */
        if (message.proofOps)
            ProofOps.internalBinaryWrite(message.proofOps, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 9; */
        if (message.height !== "0")
            writer.tag(9, WireType.Varint).int64(message.height);
        /* string codespace = 10; */
        if (message.codespace !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseQuery
 */
export const ResponseQuery = new ResponseQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseBeginBlock$Type extends MessageType<ResponseBeginBlock> {
    constructor() {
        super("tendermint.abci.ResponseBeginBlock", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResponseBeginBlock>): ResponseBeginBlock {
        const message = { events: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseBeginBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseBeginBlock): ResponseBeginBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseBeginBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tendermint.abci.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseBeginBlock
 */
export const ResponseBeginBlock = new ResponseBeginBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseCheckTx$Type extends MessageType<ResponseCheckTx> {
    constructor() {
        super("tendermint.abci.ResponseCheckTx", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseCheckTx>): ResponseCheckTx {
        const message = { code: 0, data: new Uint8Array(0), log: "", info: "", gasWanted: "0", gasUsed: "0", events: [], codespace: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseCheckTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseCheckTx): ResponseCheckTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"];*/ 5:
                    message.gasWanted = reader.int64().toString();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"];*/ 6:
                    message.gasUsed = reader.int64().toString();
                    break;
                case /* repeated tendermint.abci.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseCheckTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== "0")
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== "0")
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated tendermint.abci.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseCheckTx
 */
export const ResponseCheckTx = new ResponseCheckTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseDeliverTx$Type extends MessageType<ResponseDeliverTx> {
    constructor() {
        super("tendermint.abci.ResponseDeliverTx", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseDeliverTx>): ResponseDeliverTx {
        const message = { code: 0, data: new Uint8Array(0), log: "", info: "", gasWanted: "0", gasUsed: "0", events: [], codespace: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseDeliverTx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseDeliverTx): ResponseDeliverTx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"];*/ 5:
                    message.gasWanted = reader.int64().toString();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"];*/ 6:
                    message.gasUsed = reader.int64().toString();
                    break;
                case /* repeated tendermint.abci.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseDeliverTx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== "0")
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== "0")
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated tendermint.abci.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseDeliverTx
 */
export const ResponseDeliverTx = new ResponseDeliverTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseEndBlock$Type extends MessageType<ResponseEndBlock> {
    constructor() {
        super("tendermint.abci.ResponseEndBlock", [
            { no: 1, name: "validator_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 2, name: "consensus_param_updates", kind: "message", T: () => ConsensusParams },
            { no: 3, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<ResponseEndBlock>): ResponseEndBlock {
        const message = { validatorUpdates: [], events: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseEndBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseEndBlock): ResponseEndBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.ValidatorUpdate validator_updates */ 1:
                    message.validatorUpdates.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tendermint.abci.ConsensusParams consensus_param_updates */ 2:
                    message.consensusParamUpdates = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParamUpdates);
                    break;
                case /* repeated tendermint.abci.Event events */ 3:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseEndBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tendermint.abci.ValidatorUpdate validator_updates = 1; */
        for (let i = 0; i < message.validatorUpdates.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validatorUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ConsensusParams consensus_param_updates = 2; */
        if (message.consensusParamUpdates)
            ConsensusParams.internalBinaryWrite(message.consensusParamUpdates, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Event events = 3; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseEndBlock
 */
export const ResponseEndBlock = new ResponseEndBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseCommit$Type extends MessageType<ResponseCommit> {
    constructor() {
        super("tendermint.abci.ResponseCommit", [
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "retain_height", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseCommit>): ResponseCommit {
        const message = { data: new Uint8Array(0), retainHeight: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseCommit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseCommit): ResponseCommit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* int64 retain_height */ 3:
                    message.retainHeight = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseCommit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* int64 retain_height = 3; */
        if (message.retainHeight !== "0")
            writer.tag(3, WireType.Varint).int64(message.retainHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseCommit
 */
export const ResponseCommit = new ResponseCommit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseListSnapshots$Type extends MessageType<ResponseListSnapshots> {
    constructor() {
        super("tendermint.abci.ResponseListSnapshots", [
            { no: 1, name: "snapshots", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Snapshot }
        ]);
    }
    create(value?: PartialMessage<ResponseListSnapshots>): ResponseListSnapshots {
        const message = { snapshots: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseListSnapshots>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseListSnapshots): ResponseListSnapshots {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.Snapshot snapshots */ 1:
                    message.snapshots.push(Snapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseListSnapshots, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tendermint.abci.Snapshot snapshots = 1; */
        for (let i = 0; i < message.snapshots.length; i++)
            Snapshot.internalBinaryWrite(message.snapshots[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseListSnapshots
 */
export const ResponseListSnapshots = new ResponseListSnapshots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseOfferSnapshot$Type extends MessageType<ResponseOfferSnapshot> {
    constructor() {
        super("tendermint.abci.ResponseOfferSnapshot", [
            { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseOfferSnapshot.Result", ResponseOfferSnapshot_Result] }
        ]);
    }
    create(value?: PartialMessage<ResponseOfferSnapshot>): ResponseOfferSnapshot {
        const message = { result: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseOfferSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseOfferSnapshot): ResponseOfferSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseOfferSnapshot.Result result */ 1:
                    message.result = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseOfferSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseOfferSnapshot.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseOfferSnapshot
 */
export const ResponseOfferSnapshot = new ResponseOfferSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseLoadSnapshotChunk$Type extends MessageType<ResponseLoadSnapshotChunk> {
    constructor() {
        super("tendermint.abci.ResponseLoadSnapshotChunk", [
            { no: 1, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseLoadSnapshotChunk>): ResponseLoadSnapshotChunk {
        const message = { chunk: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseLoadSnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseLoadSnapshotChunk): ResponseLoadSnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes chunk */ 1:
                    message.chunk = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseLoadSnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes chunk = 1; */
        if (message.chunk.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseLoadSnapshotChunk
 */
export const ResponseLoadSnapshotChunk = new ResponseLoadSnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseApplySnapshotChunk$Type extends MessageType<ResponseApplySnapshotChunk> {
    constructor() {
        super("tendermint.abci.ResponseApplySnapshotChunk", [
            { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseApplySnapshotChunk.Result", ResponseApplySnapshotChunk_Result] },
            { no: 2, name: "refetch_chunks", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "reject_senders", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseApplySnapshotChunk>): ResponseApplySnapshotChunk {
        const message = { result: 0, refetchChunks: [], rejectSenders: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResponseApplySnapshotChunk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseApplySnapshotChunk): ResponseApplySnapshotChunk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseApplySnapshotChunk.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* repeated uint32 refetch_chunks */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.refetchChunks.push(reader.uint32());
                    else
                        message.refetchChunks.push(reader.uint32());
                    break;
                case /* repeated string reject_senders */ 3:
                    message.rejectSenders.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseApplySnapshotChunk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.ResponseApplySnapshotChunk.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* repeated uint32 refetch_chunks = 2; */
        if (message.refetchChunks.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.refetchChunks.length; i++)
                writer.uint32(message.refetchChunks[i]);
            writer.join();
        }
        /* repeated string reject_senders = 3; */
        for (let i = 0; i < message.rejectSenders.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.rejectSenders[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseApplySnapshotChunk
 */
export const ResponseApplySnapshotChunk = new ResponseApplySnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsensusParams$Type extends MessageType<ConsensusParams> {
    constructor() {
        super("tendermint.abci.ConsensusParams", [
            { no: 1, name: "block", kind: "message", T: () => BlockParams },
            { no: 2, name: "evidence", kind: "message", T: () => EvidenceParams },
            { no: 3, name: "validator", kind: "message", T: () => ValidatorParams },
            { no: 4, name: "version", kind: "message", T: () => VersionParams }
        ]);
    }
    create(value?: PartialMessage<ConsensusParams>): ConsensusParams {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConsensusParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsensusParams): ConsensusParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.BlockParams block */ 1:
                    message.block = BlockParams.internalBinaryRead(reader, reader.uint32(), options, message.block);
                    break;
                case /* tendermint.types.EvidenceParams evidence */ 2:
                    message.evidence = EvidenceParams.internalBinaryRead(reader, reader.uint32(), options, message.evidence);
                    break;
                case /* tendermint.types.ValidatorParams validator */ 3:
                    message.validator = ValidatorParams.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* tendermint.types.VersionParams version */ 4:
                    message.version = VersionParams.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsensusParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.BlockParams block = 1; */
        if (message.block)
            BlockParams.internalBinaryWrite(message.block, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.EvidenceParams evidence = 2; */
        if (message.evidence)
            EvidenceParams.internalBinaryWrite(message.evidence, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.ValidatorParams validator = 3; */
        if (message.validator)
            ValidatorParams.internalBinaryWrite(message.validator, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.VersionParams version = 4; */
        if (message.version)
            VersionParams.internalBinaryWrite(message.version, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ConsensusParams
 */
export const ConsensusParams = new ConsensusParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockParams$Type extends MessageType<BlockParams> {
    constructor() {
        super("tendermint.abci.BlockParams", [
            { no: 1, name: "max_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "max_gas", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<BlockParams>): BlockParams {
        const message = { maxBytes: "0", maxGas: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockParams): BlockParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 max_bytes */ 1:
                    message.maxBytes = reader.int64().toString();
                    break;
                case /* int64 max_gas */ 2:
                    message.maxGas = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 max_bytes = 1; */
        if (message.maxBytes !== "0")
            writer.tag(1, WireType.Varint).int64(message.maxBytes);
        /* int64 max_gas = 2; */
        if (message.maxGas !== "0")
            writer.tag(2, WireType.Varint).int64(message.maxGas);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.BlockParams
 */
export const BlockParams = new BlockParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastCommitInfo$Type extends MessageType<LastCommitInfo> {
    constructor() {
        super("tendermint.abci.LastCommitInfo", [
            { no: 1, name: "round", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "votes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VoteInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<LastCommitInfo>): LastCommitInfo {
        const message = { round: 0, votes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LastCommitInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LastCommitInfo): LastCommitInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32();
                    break;
                case /* repeated tendermint.abci.VoteInfo votes */ 2:
                    message.votes.push(VoteInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LastCommitInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 round = 1; */
        if (message.round !== 0)
            writer.tag(1, WireType.Varint).int32(message.round);
        /* repeated tendermint.abci.VoteInfo votes = 2; */
        for (let i = 0; i < message.votes.length; i++)
            VoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.LastCommitInfo
 */
export const LastCommitInfo = new LastCommitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("tendermint.abci.Event", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventAttribute, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "attributes,omitempty" } }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = { type: "", attributes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated tendermint.abci.EventAttribute attributes */ 2:
                    message.attributes.push(EventAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated tendermint.abci.EventAttribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            EventAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAttribute$Type extends MessageType<EventAttribute> {
    constructor() {
        super("tendermint.abci.EventAttribute", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "index", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EventAttribute>): EventAttribute {
        const message = { key: new Uint8Array(0), value: new Uint8Array(0), index: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EventAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventAttribute): EventAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* bool index */ 3:
                    message.index = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* bool index = 3; */
        if (message.index !== false)
            writer.tag(3, WireType.Varint).bool(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.EventAttribute
 */
export const EventAttribute = new EventAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxResult$Type extends MessageType<TxResult> {
    constructor() {
        super("tendermint.abci.TxResult", [
            { no: 1, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "result", kind: "message", T: () => ResponseDeliverTx, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<TxResult>): TxResult {
        const message = { height: "0", index: 0, tx: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxResult): TxResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 height */ 1:
                    message.height = reader.int64().toString();
                    break;
                case /* uint32 index */ 2:
                    message.index = reader.uint32();
                    break;
                case /* bytes tx */ 3:
                    message.tx = reader.bytes();
                    break;
                case /* tendermint.abci.ResponseDeliverTx result */ 4:
                    message.result = ResponseDeliverTx.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).int64(message.height);
        /* uint32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.index);
        /* bytes tx = 3; */
        if (message.tx.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.tx);
        /* tendermint.abci.ResponseDeliverTx result = 4; */
        if (message.result)
            ResponseDeliverTx.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.TxResult
 */
export const TxResult = new TxResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Validator$Type extends MessageType<Validator> {
    constructor() {
        super("tendermint.abci.Validator", [
            { no: 1, name: "address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Validator>): Validator {
        const message = { address: new Uint8Array(0), power: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Validator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Validator): Validator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes address */ 1:
                    message.address = reader.bytes();
                    break;
                case /* int64 power */ 3:
                    message.power = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Validator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes address = 1; */
        if (message.address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.address);
        /* int64 power = 3; */
        if (message.power !== "0")
            writer.tag(3, WireType.Varint).int64(message.power);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Validator
 */
export const Validator = new Validator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidatorUpdate$Type extends MessageType<ValidatorUpdate> {
    constructor() {
        super("tendermint.abci.ValidatorUpdate", [
            { no: 1, name: "pub_key", kind: "message", T: () => PublicKey, options: { "gogoproto.nullable": false } },
            { no: 2, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<ValidatorUpdate>): ValidatorUpdate {
        const message = { power: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidatorUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorUpdate): ValidatorUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.crypto.PublicKey pub_key */ 1:
                    message.pubKey = PublicKey.internalBinaryRead(reader, reader.uint32(), options, message.pubKey);
                    break;
                case /* int64 power */ 2:
                    message.power = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidatorUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.crypto.PublicKey pub_key = 1; */
        if (message.pubKey)
            PublicKey.internalBinaryWrite(message.pubKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 power = 2; */
        if (message.power !== "0")
            writer.tag(2, WireType.Varint).int64(message.power);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ValidatorUpdate
 */
export const ValidatorUpdate = new ValidatorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoteInfo$Type extends MessageType<VoteInfo> {
    constructor() {
        super("tendermint.abci.VoteInfo", [
            { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 2, name: "signed_last_block", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VoteInfo>): VoteInfo {
        const message = { signedLastBlock: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<VoteInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoteInfo): VoteInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.Validator validator */ 1:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* bool signed_last_block */ 2:
                    message.signedLastBlock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoteInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.Validator validator = 1; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool signed_last_block = 2; */
        if (message.signedLastBlock !== false)
            writer.tag(2, WireType.Varint).bool(message.signedLastBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.VoteInfo
 */
export const VoteInfo = new VoteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Evidence$Type extends MessageType<Evidence> {
    constructor() {
        super("tendermint.abci.Evidence", [
            { no: 1, name: "type", kind: "enum", T: () => ["tendermint.abci.EvidenceType", EvidenceType] },
            { no: 2, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 5, name: "total_voting_power", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<Evidence>): Evidence {
        const message = { type: 0, height: "0", totalVotingPower: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Evidence>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Evidence): Evidence {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.EvidenceType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* tendermint.abci.Validator validator */ 2:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp time */ 4:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* int64 total_voting_power */ 5:
                    message.totalVotingPower = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Evidence, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tendermint.abci.EvidenceType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* tendermint.abci.Validator validator = 2; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 3; */
        if (message.height !== "0")
            writer.tag(3, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 4; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_voting_power = 5; */
        if (message.totalVotingPower !== "0")
            writer.tag(5, WireType.Varint).int64(message.totalVotingPower);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Evidence
 */
export const Evidence = new Evidence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Snapshot$Type extends MessageType<Snapshot> {
    constructor() {
        super("tendermint.abci.Snapshot", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Snapshot>): Snapshot {
        const message = { height: "0", format: 0, chunks: 0, hash: new Uint8Array(0), metadata: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Snapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Snapshot): Snapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toString();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunks */ 3:
                    message.chunks = reader.uint32();
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* bytes metadata */ 5:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Snapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunks = 3; */
        if (message.chunks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunks);
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* bytes metadata = 5; */
        if (message.metadata.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Snapshot
 */
export const Snapshot = new Snapshot$Type();
/**
 * @generated ServiceType for protobuf service tendermint.abci.ABCIApplication
 */
export const ABCIApplication = new ServiceType("tendermint.abci.ABCIApplication", [
    { name: "Echo", options: {}, I: RequestEcho, O: ResponseEcho },
    { name: "Flush", options: {}, I: RequestFlush, O: ResponseFlush },
    { name: "Info", options: {}, I: RequestInfo, O: ResponseInfo },
    { name: "SetOption", options: {}, I: RequestSetOption, O: ResponseSetOption },
    { name: "DeliverTx", options: {}, I: RequestDeliverTx, O: ResponseDeliverTx },
    { name: "CheckTx", options: {}, I: RequestCheckTx, O: ResponseCheckTx },
    { name: "Query", options: {}, I: RequestQuery, O: ResponseQuery },
    { name: "Commit", options: {}, I: RequestCommit, O: ResponseCommit },
    { name: "InitChain", options: {}, I: RequestInitChain, O: ResponseInitChain },
    { name: "BeginBlock", options: {}, I: RequestBeginBlock, O: ResponseBeginBlock },
    { name: "EndBlock", options: {}, I: RequestEndBlock, O: ResponseEndBlock },
    { name: "ListSnapshots", options: {}, I: RequestListSnapshots, O: ResponseListSnapshots },
    { name: "OfferSnapshot", options: {}, I: RequestOfferSnapshot, O: ResponseOfferSnapshot },
    { name: "LoadSnapshotChunk", options: {}, I: RequestLoadSnapshotChunk, O: ResponseLoadSnapshotChunk },
    { name: "ApplySnapshotChunk", options: {}, I: RequestApplySnapshotChunk, O: ResponseApplySnapshotChunk }
]);
