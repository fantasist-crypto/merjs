// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "ethermint/evm/v1/evm.proto" (package "ethermint.evm.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Params defines the EVM module parameters
 *
 * @generated from protobuf message ethermint.evm.v1.Params
 */
export interface Params {
    /**
     * evm denom represents the token denomination used to run the EVM state
     * transitions.
     *
     * @generated from protobuf field: string evm_denom = 1;
     */
    evmDenom: string;
    /**
     * enable create toggles state transitions that use the vm.Create function
     *
     * @generated from protobuf field: bool enable_create = 2;
     */
    enableCreate: boolean;
    /**
     * enable call toggles state transitions that use the vm.Call function
     *
     * @generated from protobuf field: bool enable_call = 3;
     */
    enableCall: boolean;
    /**
     * extra eips defines the additional EIPs for the vm.Config
     *
     * @generated from protobuf field: repeated int64 extra_eips = 4;
     */
    extraEips: string[];
    /**
     * chain config defines the EVM chain configuration parameters
     *
     * @generated from protobuf field: ethermint.evm.v1.ChainConfig chain_config = 5;
     */
    chainConfig?: ChainConfig;
}
/**
 * ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
 * instead of *big.Int.
 *
 * @generated from protobuf message ethermint.evm.v1.ChainConfig
 */
export interface ChainConfig {
    /**
     * Homestead switch block (nil no fork, 0 = already homestead)
     *
     * @generated from protobuf field: string homestead_block = 1;
     */
    homesteadBlock: string;
    /**
     * TheDAO hard-fork switch block (nil no fork)
     *
     * @generated from protobuf field: string dao_fork_block = 2;
     */
    daoForkBlock: string;
    /**
     * Whether the nodes supports or opposes the DAO hard-fork
     *
     * @generated from protobuf field: bool dao_fork_support = 3;
     */
    daoForkSupport: boolean;
    /**
     * EIP150 implements the Gas price changes
     * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
     *
     * @generated from protobuf field: string eip150_block = 4;
     */
    eip150Block: string;
    /**
     * EIP150 HF hash (needed for header only clients as only gas pricing changed)
     *
     * @generated from protobuf field: string eip150_hash = 5;
     */
    eip150Hash: string;
    /**
     * EIP155Block HF block
     *
     * @generated from protobuf field: string eip155_block = 6;
     */
    eip155Block: string;
    /**
     * EIP158 HF block
     *
     * @generated from protobuf field: string eip158_block = 7;
     */
    eip158Block: string;
    /**
     * Byzantium switch block (nil no fork, 0 = already on byzantium)
     *
     * @generated from protobuf field: string byzantium_block = 8;
     */
    byzantiumBlock: string;
    /**
     * Constantinople switch block (nil no fork, 0 = already activated)
     *
     * @generated from protobuf field: string constantinople_block = 9;
     */
    constantinopleBlock: string;
    /**
     * Petersburg switch block (nil same as Constantinople)
     *
     * @generated from protobuf field: string petersburg_block = 10;
     */
    petersburgBlock: string;
    /**
     * Istanbul switch block (nil no fork, 0 = already on istanbul)
     *
     * @generated from protobuf field: string istanbul_block = 11;
     */
    istanbulBlock: string;
    /**
     * Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)
     *
     * @generated from protobuf field: string muir_glacier_block = 12;
     */
    muirGlacierBlock: string;
    /**
     * Berlin switch block (nil = no fork, 0 = already on berlin)
     *
     * @generated from protobuf field: string berlin_block = 13;
     */
    berlinBlock: string;
    /**
     * London switch block (nil = no fork, 0 = already on london)
     *
     * @generated from protobuf field: string london_block = 17;
     */
    londonBlock: string;
    /**
     * Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)
     *
     * @generated from protobuf field: string arrow_glacier_block = 18;
     */
    arrowGlacierBlock: string;
    /**
     * EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings)
     *
     * @generated from protobuf field: string merge_fork_block = 19;
     */
    mergeForkBlock: string;
}
/**
 * State represents a single Storage key value pair item.
 *
 * @generated from protobuf message ethermint.evm.v1.State
 */
export interface State {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * TransactionLogs define the logs generated from a transaction execution
 * with a given hash. It it used for import/export data as transactions are not
 * persisted on blockchain state after an upgrade.
 *
 * @generated from protobuf message ethermint.evm.v1.TransactionLogs
 */
export interface TransactionLogs {
    /**
     * @generated from protobuf field: string hash = 1;
     */
    hash: string;
    /**
     * @generated from protobuf field: repeated ethermint.evm.v1.Log logs = 2;
     */
    logs: Log[];
}
/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 *
 * Consensus fields:
 *
 * @generated from protobuf message ethermint.evm.v1.Log
 */
export interface Log {
    /**
     * address of the contract that generated the event
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * list of topics provided by the contract.
     *
     * @generated from protobuf field: repeated string topics = 2;
     */
    topics: string[];
    /**
     * supplied by the contract, usually ABI-encoded
     *
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
    // Derived fields. These fields are filled in by the node
    // but not secured by consensus.

    /**
     * block in which the transaction was included
     *
     * @generated from protobuf field: uint64 block_number = 4;
     */
    blockNumber: string;
    /**
     * hash of the transaction
     *
     * @generated from protobuf field: string tx_hash = 5;
     */
    txHash: string;
    /**
     * index of the transaction in the block
     *
     * @generated from protobuf field: uint64 tx_index = 6;
     */
    txIndex: string;
    /**
     * hash of the block in which the transaction was included
     *
     * @generated from protobuf field: string block_hash = 7;
     */
    blockHash: string;
    /**
     * index of the log in the block
     *
     * @generated from protobuf field: uint64 index = 8;
     */
    index: string;
    /**
     * The Removed field is true if this log was reverted due to a chain
     * reorganisation. You must pay attention to this field if you receive logs
     * through a filter query.
     *
     * @generated from protobuf field: bool removed = 9;
     */
    removed: boolean;
}
/**
 * TxResult stores results of Tx execution.
 *
 * @generated from protobuf message ethermint.evm.v1.TxResult
 */
export interface TxResult {
    /**
     * contract_address contains the ethereum address of the created contract (if
     * any). If the state transition is an evm.Call, the contract address will be
     * empty.
     *
     * @generated from protobuf field: string contract_address = 1;
     */
    contractAddress: string;
    /**
     * bloom represents the bloom filter bytes
     *
     * @generated from protobuf field: bytes bloom = 2;
     */
    bloom: Uint8Array;
    /**
     * tx_logs contains the transaction hash and the proto-compatible ethereum
     * logs.
     *
     * @generated from protobuf field: ethermint.evm.v1.TransactionLogs tx_logs = 3;
     */
    txLogs?: TransactionLogs;
    /**
     * ret defines the bytes from the execution.
     *
     * @generated from protobuf field: bytes ret = 4;
     */
    ret: Uint8Array;
    /**
     * reverted flag is set to true when the call has been reverted
     *
     * @generated from protobuf field: bool reverted = 5;
     */
    reverted: boolean;
    /**
     * gas_used notes the amount of gas consumed while execution
     *
     * @generated from protobuf field: uint64 gas_used = 6;
     */
    gasUsed: string;
}
/**
 * AccessTuple is the element type of an access list.
 *
 * @generated from protobuf message ethermint.evm.v1.AccessTuple
 */
export interface AccessTuple {
    /**
     * hex formatted ethereum address
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * hex formatted hashes of the storage keys
     *
     * @generated from protobuf field: repeated string storage_keys = 2;
     */
    storageKeys: string[];
}
/**
 * TraceConfig holds extra parameters to trace functions.
 *
 * @generated from protobuf message ethermint.evm.v1.TraceConfig
 */
export interface TraceConfig {
    /**
     * custom javascript tracer
     *
     * @generated from protobuf field: string tracer = 1;
     */
    tracer: string;
    /**
     * overrides the default timeout of 5 seconds for JavaScript-based tracing
     * calls
     *
     * @generated from protobuf field: string timeout = 2;
     */
    timeout: string;
    /**
     * number of blocks the tracer is willing to go back
     *
     * @generated from protobuf field: uint64 reexec = 3;
     */
    reexec: string;
    /**
     * disable stack capture
     *
     * @generated from protobuf field: bool disable_stack = 5;
     */
    disableStack: boolean;
    /**
     * disable storage capture
     *
     * @generated from protobuf field: bool disable_storage = 6;
     */
    disableStorage: boolean;
    /**
     * print output during capture end
     *
     * @generated from protobuf field: bool debug = 8;
     */
    debug: boolean;
    /**
     * maximum length of output, but zero means unlimited
     *
     * @generated from protobuf field: int32 limit = 9;
     */
    limit: number;
    /**
     * Chain overrides, can be used to execute a trace using future fork rules
     *
     * @generated from protobuf field: ethermint.evm.v1.ChainConfig overrides = 10;
     */
    overrides?: ChainConfig;
    /**
     * enable memory capture
     *
     * @generated from protobuf field: bool enable_memory = 11;
     */
    enableMemory: boolean;
    /**
     * enable return data capture
     *
     * @generated from protobuf field: bool enable_return_data = 12;
     */
    enableReturnData: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class Params$Type extends MessageType<Params> {
    constructor() {
        super("ethermint.evm.v1.Params", [
            { no: 1, name: "evm_denom", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"evm_denom\"" } },
            { no: 2, name: "enable_create", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.moretags": "yaml:\"enable_create\"" } },
            { no: 3, name: "enable_call", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.moretags": "yaml:\"enable_call\"" } },
            { no: 4, name: "extra_eips", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 3 /*ScalarType.INT64*/, options: { "gogoproto.customname": "ExtraEIPs", "gogoproto.moretags": "yaml:\"extra_eips\"" } },
            { no: 5, name: "chain_config", kind: "message", T: () => ChainConfig, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"chain_config\"" } }
        ]);
    }
    create(value?: PartialMessage<Params>): Params {
        const message = { evmDenom: "", enableCreate: false, enableCall: false, extraEips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Params>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string evm_denom */ 1:
                    message.evmDenom = reader.string();
                    break;
                case /* bool enable_create */ 2:
                    message.enableCreate = reader.bool();
                    break;
                case /* bool enable_call */ 3:
                    message.enableCall = reader.bool();
                    break;
                case /* repeated int64 extra_eips */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.extraEips.push(reader.int64().toString());
                    else
                        message.extraEips.push(reader.int64().toString());
                    break;
                case /* ethermint.evm.v1.ChainConfig chain_config */ 5:
                    message.chainConfig = ChainConfig.internalBinaryRead(reader, reader.uint32(), options, message.chainConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string evm_denom = 1; */
        if (message.evmDenom !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.evmDenom);
        /* bool enable_create = 2; */
        if (message.enableCreate !== false)
            writer.tag(2, WireType.Varint).bool(message.enableCreate);
        /* bool enable_call = 3; */
        if (message.enableCall !== false)
            writer.tag(3, WireType.Varint).bool(message.enableCall);
        /* repeated int64 extra_eips = 4; */
        if (message.extraEips.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.extraEips.length; i++)
                writer.int64(message.extraEips[i]);
            writer.join();
        }
        /* ethermint.evm.v1.ChainConfig chain_config = 5; */
        if (message.chainConfig)
            ChainConfig.internalBinaryWrite(message.chainConfig, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.Params
 */
export const Params = new Params$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChainConfig$Type extends MessageType<ChainConfig> {
    constructor() {
        super("ethermint.evm.v1.ChainConfig", [
            { no: 1, name: "homestead_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"homestead_block\"" } },
            { no: 2, name: "dao_fork_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.customname": "DAOForkBlock", "gogoproto.moretags": "yaml:\"dao_fork_block\"" } },
            { no: 3, name: "dao_fork_support", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.customname": "DAOForkSupport", "gogoproto.moretags": "yaml:\"dao_fork_support\"" } },
            { no: 4, name: "eip150_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.customname": "EIP150Block", "gogoproto.moretags": "yaml:\"eip150_block\"" } },
            { no: 5, name: "eip150_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customname": "EIP150Hash", "gogoproto.moretags": "yaml:\"byzantium_block\"" } },
            { no: 6, name: "eip155_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.customname": "EIP155Block", "gogoproto.moretags": "yaml:\"eip155_block\"" } },
            { no: 7, name: "eip158_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.customname": "EIP158Block", "gogoproto.moretags": "yaml:\"eip158_block\"" } },
            { no: 8, name: "byzantium_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"byzantium_block\"" } },
            { no: 9, name: "constantinople_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"constantinople_block\"" } },
            { no: 10, name: "petersburg_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"petersburg_block\"" } },
            { no: 11, name: "istanbul_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"istanbul_block\"" } },
            { no: 12, name: "muir_glacier_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"muir_glacier_block\"" } },
            { no: 13, name: "berlin_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"berlin_block\"" } },
            { no: 17, name: "london_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"london_block\"" } },
            { no: 18, name: "arrow_glacier_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"arrow_glacier_block\"" } },
            { no: 19, name: "merge_fork_block", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.customtype": "github.com/cosmos/cosmos-sdk/types.Int", "gogoproto.moretags": "yaml:\"merge_fork_block\"" } }
        ]);
    }
    create(value?: PartialMessage<ChainConfig>): ChainConfig {
        const message = { homesteadBlock: "", daoForkBlock: "", daoForkSupport: false, eip150Block: "", eip150Hash: "", eip155Block: "", eip158Block: "", byzantiumBlock: "", constantinopleBlock: "", petersburgBlock: "", istanbulBlock: "", muirGlacierBlock: "", berlinBlock: "", londonBlock: "", arrowGlacierBlock: "", mergeForkBlock: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChainConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChainConfig): ChainConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string homestead_block */ 1:
                    message.homesteadBlock = reader.string();
                    break;
                case /* string dao_fork_block */ 2:
                    message.daoForkBlock = reader.string();
                    break;
                case /* bool dao_fork_support */ 3:
                    message.daoForkSupport = reader.bool();
                    break;
                case /* string eip150_block */ 4:
                    message.eip150Block = reader.string();
                    break;
                case /* string eip150_hash */ 5:
                    message.eip150Hash = reader.string();
                    break;
                case /* string eip155_block */ 6:
                    message.eip155Block = reader.string();
                    break;
                case /* string eip158_block */ 7:
                    message.eip158Block = reader.string();
                    break;
                case /* string byzantium_block */ 8:
                    message.byzantiumBlock = reader.string();
                    break;
                case /* string constantinople_block */ 9:
                    message.constantinopleBlock = reader.string();
                    break;
                case /* string petersburg_block */ 10:
                    message.petersburgBlock = reader.string();
                    break;
                case /* string istanbul_block */ 11:
                    message.istanbulBlock = reader.string();
                    break;
                case /* string muir_glacier_block */ 12:
                    message.muirGlacierBlock = reader.string();
                    break;
                case /* string berlin_block */ 13:
                    message.berlinBlock = reader.string();
                    break;
                case /* string london_block */ 17:
                    message.londonBlock = reader.string();
                    break;
                case /* string arrow_glacier_block */ 18:
                    message.arrowGlacierBlock = reader.string();
                    break;
                case /* string merge_fork_block */ 19:
                    message.mergeForkBlock = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChainConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string homestead_block = 1; */
        if (message.homesteadBlock !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.homesteadBlock);
        /* string dao_fork_block = 2; */
        if (message.daoForkBlock !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.daoForkBlock);
        /* bool dao_fork_support = 3; */
        if (message.daoForkSupport !== false)
            writer.tag(3, WireType.Varint).bool(message.daoForkSupport);
        /* string eip150_block = 4; */
        if (message.eip150Block !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.eip150Block);
        /* string eip150_hash = 5; */
        if (message.eip150Hash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.eip150Hash);
        /* string eip155_block = 6; */
        if (message.eip155Block !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.eip155Block);
        /* string eip158_block = 7; */
        if (message.eip158Block !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.eip158Block);
        /* string byzantium_block = 8; */
        if (message.byzantiumBlock !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.byzantiumBlock);
        /* string constantinople_block = 9; */
        if (message.constantinopleBlock !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.constantinopleBlock);
        /* string petersburg_block = 10; */
        if (message.petersburgBlock !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.petersburgBlock);
        /* string istanbul_block = 11; */
        if (message.istanbulBlock !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.istanbulBlock);
        /* string muir_glacier_block = 12; */
        if (message.muirGlacierBlock !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.muirGlacierBlock);
        /* string berlin_block = 13; */
        if (message.berlinBlock !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.berlinBlock);
        /* string london_block = 17; */
        if (message.londonBlock !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.londonBlock);
        /* string arrow_glacier_block = 18; */
        if (message.arrowGlacierBlock !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.arrowGlacierBlock);
        /* string merge_fork_block = 19; */
        if (message.mergeForkBlock !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.mergeForkBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.ChainConfig
 */
export const ChainConfig = new ChainConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class State$Type extends MessageType<State> {
    constructor() {
        super("ethermint.evm.v1.State", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<State>): State {
        const message = { key: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<State>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: State): State {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: State, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.State
 */
export const State = new State$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionLogs$Type extends MessageType<TransactionLogs> {
    constructor() {
        super("ethermint.evm.v1.TransactionLogs", [
            { no: 1, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "logs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Log }
        ]);
    }
    create(value?: PartialMessage<TransactionLogs>): TransactionLogs {
        const message = { hash: "", logs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionLogs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionLogs): TransactionLogs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash */ 1:
                    message.hash = reader.string();
                    break;
                case /* repeated ethermint.evm.v1.Log logs */ 2:
                    message.logs.push(Log.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionLogs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash = 1; */
        if (message.hash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hash);
        /* repeated ethermint.evm.v1.Log logs = 2; */
        for (let i = 0; i < message.logs.length; i++)
            Log.internalBinaryWrite(message.logs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.TransactionLogs
 */
export const TransactionLogs = new TransactionLogs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Log$Type extends MessageType<Log> {
    constructor() {
        super("ethermint.evm.v1.Log", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "topics", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "block_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "gogoproto.jsontag": "blockNumber" } },
            { no: 5, name: "tx_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "transactionHash" } },
            { no: 6, name: "tx_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "gogoproto.jsontag": "transactionIndex" } },
            { no: 7, name: "block_hash", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "blockHash" } },
            { no: 8, name: "index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "gogoproto.jsontag": "logIndex" } },
            { no: 9, name: "removed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Log>): Log {
        const message = { address: "", topics: [], data: new Uint8Array(0), blockNumber: "0", txHash: "", txIndex: "0", blockHash: "", index: "0", removed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Log>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Log): Log {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* repeated string topics */ 2:
                    message.topics.push(reader.string());
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                case /* uint64 block_number */ 4:
                    message.blockNumber = reader.uint64().toString();
                    break;
                case /* string tx_hash */ 5:
                    message.txHash = reader.string();
                    break;
                case /* uint64 tx_index */ 6:
                    message.txIndex = reader.uint64().toString();
                    break;
                case /* string block_hash */ 7:
                    message.blockHash = reader.string();
                    break;
                case /* uint64 index */ 8:
                    message.index = reader.uint64().toString();
                    break;
                case /* bool removed */ 9:
                    message.removed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Log, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* repeated string topics = 2; */
        for (let i = 0; i < message.topics.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.topics[i]);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* uint64 block_number = 4; */
        if (message.blockNumber !== "0")
            writer.tag(4, WireType.Varint).uint64(message.blockNumber);
        /* string tx_hash = 5; */
        if (message.txHash !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.txHash);
        /* uint64 tx_index = 6; */
        if (message.txIndex !== "0")
            writer.tag(6, WireType.Varint).uint64(message.txIndex);
        /* string block_hash = 7; */
        if (message.blockHash !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.blockHash);
        /* uint64 index = 8; */
        if (message.index !== "0")
            writer.tag(8, WireType.Varint).uint64(message.index);
        /* bool removed = 9; */
        if (message.removed !== false)
            writer.tag(9, WireType.Varint).bool(message.removed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.Log
 */
export const Log = new Log$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxResult$Type extends MessageType<TxResult> {
    constructor() {
        super("ethermint.evm.v1.TxResult", [
            { no: 1, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"contract_address\"" } },
            { no: 2, name: "bloom", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "tx_logs", kind: "message", T: () => TransactionLogs, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"tx_logs\"" } },
            { no: 4, name: "ret", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "reverted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "gas_used", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<TxResult>): TxResult {
        const message = { contractAddress: "", bloom: new Uint8Array(0), ret: new Uint8Array(0), reverted: false, gasUsed: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxResult): TxResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_address */ 1:
                    message.contractAddress = reader.string();
                    break;
                case /* bytes bloom */ 2:
                    message.bloom = reader.bytes();
                    break;
                case /* ethermint.evm.v1.TransactionLogs tx_logs */ 3:
                    message.txLogs = TransactionLogs.internalBinaryRead(reader, reader.uint32(), options, message.txLogs);
                    break;
                case /* bytes ret */ 4:
                    message.ret = reader.bytes();
                    break;
                case /* bool reverted */ 5:
                    message.reverted = reader.bool();
                    break;
                case /* uint64 gas_used */ 6:
                    message.gasUsed = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_address = 1; */
        if (message.contractAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractAddress);
        /* bytes bloom = 2; */
        if (message.bloom.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.bloom);
        /* ethermint.evm.v1.TransactionLogs tx_logs = 3; */
        if (message.txLogs)
            TransactionLogs.internalBinaryWrite(message.txLogs, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bytes ret = 4; */
        if (message.ret.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.ret);
        /* bool reverted = 5; */
        if (message.reverted !== false)
            writer.tag(5, WireType.Varint).bool(message.reverted);
        /* uint64 gas_used = 6; */
        if (message.gasUsed !== "0")
            writer.tag(6, WireType.Varint).uint64(message.gasUsed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.TxResult
 */
export const TxResult = new TxResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessTuple$Type extends MessageType<AccessTuple> {
    constructor() {
        super("ethermint.evm.v1.AccessTuple", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "storage_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.jsontag": "storageKeys" } }
        ], { "gogoproto.goproto_getters": false });
    }
    create(value?: PartialMessage<AccessTuple>): AccessTuple {
        const message = { address: "", storageKeys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccessTuple>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessTuple): AccessTuple {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* repeated string storage_keys */ 2:
                    message.storageKeys.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessTuple, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* repeated string storage_keys = 2; */
        for (let i = 0; i < message.storageKeys.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.storageKeys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.AccessTuple
 */
export const AccessTuple = new AccessTuple$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraceConfig$Type extends MessageType<TraceConfig> {
    constructor() {
        super("ethermint.evm.v1.TraceConfig", [
            { no: 1, name: "tracer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timeout", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reexec", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "disable_stack", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "disableStack" } },
            { no: 6, name: "disable_storage", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "disableStorage" } },
            { no: 8, name: "debug", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "overrides", kind: "message", T: () => ChainConfig },
            { no: 11, name: "enable_memory", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "enableMemory" } },
            { no: 12, name: "enable_return_data", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "gogoproto.jsontag": "enableReturnData" } }
        ]);
    }
    create(value?: PartialMessage<TraceConfig>): TraceConfig {
        const message = { tracer: "", timeout: "", reexec: "0", disableStack: false, disableStorage: false, debug: false, limit: 0, enableMemory: false, enableReturnData: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TraceConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraceConfig): TraceConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tracer */ 1:
                    message.tracer = reader.string();
                    break;
                case /* string timeout */ 2:
                    message.timeout = reader.string();
                    break;
                case /* uint64 reexec */ 3:
                    message.reexec = reader.uint64().toString();
                    break;
                case /* bool disable_stack */ 5:
                    message.disableStack = reader.bool();
                    break;
                case /* bool disable_storage */ 6:
                    message.disableStorage = reader.bool();
                    break;
                case /* bool debug */ 8:
                    message.debug = reader.bool();
                    break;
                case /* int32 limit */ 9:
                    message.limit = reader.int32();
                    break;
                case /* ethermint.evm.v1.ChainConfig overrides */ 10:
                    message.overrides = ChainConfig.internalBinaryRead(reader, reader.uint32(), options, message.overrides);
                    break;
                case /* bool enable_memory */ 11:
                    message.enableMemory = reader.bool();
                    break;
                case /* bool enable_return_data */ 12:
                    message.enableReturnData = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TraceConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tracer = 1; */
        if (message.tracer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tracer);
        /* string timeout = 2; */
        if (message.timeout !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.timeout);
        /* uint64 reexec = 3; */
        if (message.reexec !== "0")
            writer.tag(3, WireType.Varint).uint64(message.reexec);
        /* bool disable_stack = 5; */
        if (message.disableStack !== false)
            writer.tag(5, WireType.Varint).bool(message.disableStack);
        /* bool disable_storage = 6; */
        if (message.disableStorage !== false)
            writer.tag(6, WireType.Varint).bool(message.disableStorage);
        /* bool debug = 8; */
        if (message.debug !== false)
            writer.tag(8, WireType.Varint).bool(message.debug);
        /* int32 limit = 9; */
        if (message.limit !== 0)
            writer.tag(9, WireType.Varint).int32(message.limit);
        /* ethermint.evm.v1.ChainConfig overrides = 10; */
        if (message.overrides)
            ChainConfig.internalBinaryWrite(message.overrides, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_memory = 11; */
        if (message.enableMemory !== false)
            writer.tag(11, WireType.Varint).bool(message.enableMemory);
        /* bool enable_return_data = 12; */
        if (message.enableReturnData !== false)
            writer.tag(12, WireType.Varint).bool(message.enableReturnData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ethermint.evm.v1.TraceConfig
 */
export const TraceConfig = new TraceConfig$Type();
