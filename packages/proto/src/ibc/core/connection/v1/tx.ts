// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "ibc/core/connection/v1/tx.proto" (package "ibc.core.connection.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Height } from "../../client/v1/client";
import { Any } from "../../../../google/protobuf/any";
import { Version } from "./connection";
import { Counterparty } from "./connection";
/**
 * MsgConnectionOpenInit defines the msg sent by an account on Chain A to
 * initialize a connection with Chain B.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenInit
 */
export interface MsgConnectionOpenInit {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Counterparty counterparty = 2;
     */
    counterparty?: Counterparty;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Version version = 3;
     */
    version?: Version;
    /**
     * @generated from protobuf field: uint64 delay_period = 4;
     */
    delayPeriod: string;
    /**
     * @generated from protobuf field: string signer = 5;
     */
    signer: string;
}
/**
 * MsgConnectionOpenInitResponse defines the Msg/ConnectionOpenInit response
 * type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenInitResponse
 */
export interface MsgConnectionOpenInitResponse {
}
/**
 * MsgConnectionOpenTry defines a msg sent by a Relayer to try to open a
 * connection on Chain B.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenTry
 */
export interface MsgConnectionOpenTry {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * in the case of crossing hello's, when both chains call OpenInit, we need
     * the connection identifier of the previous connection in state INIT
     *
     * @generated from protobuf field: string previous_connection_id = 2;
     */
    previousConnectionId: string;
    /**
     * @generated from protobuf field: google.protobuf.Any client_state = 3;
     */
    clientState?: Any;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Counterparty counterparty = 4;
     */
    counterparty?: Counterparty;
    /**
     * @generated from protobuf field: uint64 delay_period = 5;
     */
    delayPeriod: string;
    /**
     * @generated from protobuf field: repeated ibc.core.connection.v1.Version counterparty_versions = 6;
     */
    counterpartyVersions: Version[];
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 7;
     */
    proofHeight?: Height;
    /**
     * proof of the initialization the connection on Chain A: `UNITIALIZED ->
     * INIT`
     *
     * @generated from protobuf field: bytes proof_init = 8;
     */
    proofInit: Uint8Array;
    /**
     * proof of client state included in message
     *
     * @generated from protobuf field: bytes proof_client = 9;
     */
    proofClient: Uint8Array;
    /**
     * proof of client consensus state
     *
     * @generated from protobuf field: bytes proof_consensus = 10;
     */
    proofConsensus: Uint8Array;
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height consensus_height = 11;
     */
    consensusHeight?: Height;
    /**
     * @generated from protobuf field: string signer = 12;
     */
    signer: string;
}
/**
 * MsgConnectionOpenTryResponse defines the Msg/ConnectionOpenTry response type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenTryResponse
 */
export interface MsgConnectionOpenTryResponse {
}
/**
 * MsgConnectionOpenAck defines a msg sent by a Relayer to Chain A to
 * acknowledge the change of connection state to TRYOPEN on Chain B.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenAck
 */
export interface MsgConnectionOpenAck {
    /**
     * @generated from protobuf field: string connection_id = 1;
     */
    connectionId: string;
    /**
     * @generated from protobuf field: string counterparty_connection_id = 2;
     */
    counterpartyConnectionId: string;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.Version version = 3;
     */
    version?: Version;
    /**
     * @generated from protobuf field: google.protobuf.Any client_state = 4;
     */
    clientState?: Any;
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 5;
     */
    proofHeight?: Height;
    /**
     * proof of the initialization the connection on Chain B: `UNITIALIZED ->
     * TRYOPEN`
     *
     * @generated from protobuf field: bytes proof_try = 6;
     */
    proofTry: Uint8Array;
    /**
     * proof of client state included in message
     *
     * @generated from protobuf field: bytes proof_client = 7;
     */
    proofClient: Uint8Array;
    /**
     * proof of client consensus state
     *
     * @generated from protobuf field: bytes proof_consensus = 8;
     */
    proofConsensus: Uint8Array;
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height consensus_height = 9;
     */
    consensusHeight?: Height;
    /**
     * @generated from protobuf field: string signer = 10;
     */
    signer: string;
}
/**
 * MsgConnectionOpenAckResponse defines the Msg/ConnectionOpenAck response type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenAckResponse
 */
export interface MsgConnectionOpenAckResponse {
}
/**
 * MsgConnectionOpenConfirm defines a msg sent by a Relayer to Chain B to
 * acknowledge the change of connection state to OPEN on Chain A.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirm
 */
export interface MsgConnectionOpenConfirm {
    /**
     * @generated from protobuf field: string connection_id = 1;
     */
    connectionId: string;
    /**
     * proof for the change of the connection state on Chain A: `INIT -> OPEN`
     *
     * @generated from protobuf field: bytes proof_ack = 2;
     */
    proofAck: Uint8Array;
    /**
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 3;
     */
    proofHeight?: Height;
    /**
     * @generated from protobuf field: string signer = 4;
     */
    signer: string;
}
/**
 * MsgConnectionOpenConfirmResponse defines the Msg/ConnectionOpenConfirm
 * response type.
 *
 * @generated from protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirmResponse
 */
export interface MsgConnectionOpenConfirmResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenInit$Type extends MessageType<MsgConnectionOpenInit> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenInit", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"client_id\"" } },
            { no: 2, name: "counterparty", kind: "message", T: () => Counterparty, options: { "gogoproto.nullable": false } },
            { no: 3, name: "version", kind: "message", T: () => Version },
            { no: 4, name: "delay_period", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "gogoproto.moretags": "yaml:\"delay_period\"" } },
            { no: 5, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgConnectionOpenInit>): MsgConnectionOpenInit {
        const message = { clientId: "", delayPeriod: "0", signer: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenInit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenInit): MsgConnectionOpenInit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* ibc.core.connection.v1.Counterparty counterparty */ 2:
                    message.counterparty = Counterparty.internalBinaryRead(reader, reader.uint32(), options, message.counterparty);
                    break;
                case /* ibc.core.connection.v1.Version version */ 3:
                    message.version = Version.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* uint64 delay_period */ 4:
                    message.delayPeriod = reader.uint64().toString();
                    break;
                case /* string signer */ 5:
                    message.signer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenInit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* ibc.core.connection.v1.Counterparty counterparty = 2; */
        if (message.counterparty)
            Counterparty.internalBinaryWrite(message.counterparty, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.connection.v1.Version version = 3; */
        if (message.version)
            Version.internalBinaryWrite(message.version, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 delay_period = 4; */
        if (message.delayPeriod !== "0")
            writer.tag(4, WireType.Varint).uint64(message.delayPeriod);
        /* string signer = 5; */
        if (message.signer !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.signer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenInit
 */
export const MsgConnectionOpenInit = new MsgConnectionOpenInit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenInitResponse$Type extends MessageType<MsgConnectionOpenInitResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenInitResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenInitResponse>): MsgConnectionOpenInitResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenInitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenInitResponse): MsgConnectionOpenInitResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgConnectionOpenInitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenInitResponse
 */
export const MsgConnectionOpenInitResponse = new MsgConnectionOpenInitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenTry$Type extends MessageType<MsgConnectionOpenTry> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenTry", [
            { no: 1, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"client_id\"" } },
            { no: 2, name: "previous_connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"previous_connection_id\"" } },
            { no: 3, name: "client_state", kind: "message", T: () => Any, options: { "gogoproto.moretags": "yaml:\"client_state\"" } },
            { no: 4, name: "counterparty", kind: "message", T: () => Counterparty, options: { "gogoproto.nullable": false } },
            { no: 5, name: "delay_period", kind: "scalar", T: 4 /*ScalarType.UINT64*/, options: { "gogoproto.moretags": "yaml:\"delay_period\"" } },
            { no: 6, name: "counterparty_versions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Version, options: { "gogoproto.moretags": "yaml:\"counterparty_versions\"" } },
            { no: 7, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"proof_height\"" } },
            { no: 8, name: "proof_init", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.moretags": "yaml:\"proof_init\"" } },
            { no: 9, name: "proof_client", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.moretags": "yaml:\"proof_client\"" } },
            { no: 10, name: "proof_consensus", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.moretags": "yaml:\"proof_consensus\"" } },
            { no: 11, name: "consensus_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"consensus_height\"" } },
            { no: 12, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgConnectionOpenTry>): MsgConnectionOpenTry {
        const message = { clientId: "", previousConnectionId: "", delayPeriod: "0", counterpartyVersions: [], proofInit: new Uint8Array(0), proofClient: new Uint8Array(0), proofConsensus: new Uint8Array(0), signer: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenTry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenTry): MsgConnectionOpenTry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string client_id */ 1:
                    message.clientId = reader.string();
                    break;
                case /* string previous_connection_id */ 2:
                    message.previousConnectionId = reader.string();
                    break;
                case /* google.protobuf.Any client_state */ 3:
                    message.clientState = Any.internalBinaryRead(reader, reader.uint32(), options, message.clientState);
                    break;
                case /* ibc.core.connection.v1.Counterparty counterparty */ 4:
                    message.counterparty = Counterparty.internalBinaryRead(reader, reader.uint32(), options, message.counterparty);
                    break;
                case /* uint64 delay_period */ 5:
                    message.delayPeriod = reader.uint64().toString();
                    break;
                case /* repeated ibc.core.connection.v1.Version counterparty_versions */ 6:
                    message.counterpartyVersions.push(Version.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 7:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                case /* bytes proof_init */ 8:
                    message.proofInit = reader.bytes();
                    break;
                case /* bytes proof_client */ 9:
                    message.proofClient = reader.bytes();
                    break;
                case /* bytes proof_consensus */ 10:
                    message.proofConsensus = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height consensus_height */ 11:
                    message.consensusHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.consensusHeight);
                    break;
                case /* string signer */ 12:
                    message.signer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenTry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string client_id = 1; */
        if (message.clientId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clientId);
        /* string previous_connection_id = 2; */
        if (message.previousConnectionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.previousConnectionId);
        /* google.protobuf.Any client_state = 3; */
        if (message.clientState)
            Any.internalBinaryWrite(message.clientState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.connection.v1.Counterparty counterparty = 4; */
        if (message.counterparty)
            Counterparty.internalBinaryWrite(message.counterparty, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint64 delay_period = 5; */
        if (message.delayPeriod !== "0")
            writer.tag(5, WireType.Varint).uint64(message.delayPeriod);
        /* repeated ibc.core.connection.v1.Version counterparty_versions = 6; */
        for (let i = 0; i < message.counterpartyVersions.length; i++)
            Version.internalBinaryWrite(message.counterpartyVersions[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height proof_height = 7; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bytes proof_init = 8; */
        if (message.proofInit.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proofInit);
        /* bytes proof_client = 9; */
        if (message.proofClient.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.proofClient);
        /* bytes proof_consensus = 10; */
        if (message.proofConsensus.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.proofConsensus);
        /* ibc.core.client.v1.Height consensus_height = 11; */
        if (message.consensusHeight)
            Height.internalBinaryWrite(message.consensusHeight, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string signer = 12; */
        if (message.signer !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.signer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenTry
 */
export const MsgConnectionOpenTry = new MsgConnectionOpenTry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenTryResponse$Type extends MessageType<MsgConnectionOpenTryResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenTryResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenTryResponse>): MsgConnectionOpenTryResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenTryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenTryResponse): MsgConnectionOpenTryResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgConnectionOpenTryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenTryResponse
 */
export const MsgConnectionOpenTryResponse = new MsgConnectionOpenTryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenAck$Type extends MessageType<MsgConnectionOpenAck> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenAck", [
            { no: 1, name: "connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"connection_id\"" } },
            { no: 2, name: "counterparty_connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"counterparty_connection_id\"" } },
            { no: 3, name: "version", kind: "message", T: () => Version },
            { no: 4, name: "client_state", kind: "message", T: () => Any, options: { "gogoproto.moretags": "yaml:\"client_state\"" } },
            { no: 5, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"proof_height\"" } },
            { no: 6, name: "proof_try", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.moretags": "yaml:\"proof_try\"" } },
            { no: 7, name: "proof_client", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.moretags": "yaml:\"proof_client\"" } },
            { no: 8, name: "proof_consensus", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.moretags": "yaml:\"proof_consensus\"" } },
            { no: 9, name: "consensus_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"consensus_height\"" } },
            { no: 10, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgConnectionOpenAck>): MsgConnectionOpenAck {
        const message = { connectionId: "", counterpartyConnectionId: "", proofTry: new Uint8Array(0), proofClient: new Uint8Array(0), proofConsensus: new Uint8Array(0), signer: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenAck): MsgConnectionOpenAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connection_id */ 1:
                    message.connectionId = reader.string();
                    break;
                case /* string counterparty_connection_id */ 2:
                    message.counterpartyConnectionId = reader.string();
                    break;
                case /* ibc.core.connection.v1.Version version */ 3:
                    message.version = Version.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* google.protobuf.Any client_state */ 4:
                    message.clientState = Any.internalBinaryRead(reader, reader.uint32(), options, message.clientState);
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 5:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                case /* bytes proof_try */ 6:
                    message.proofTry = reader.bytes();
                    break;
                case /* bytes proof_client */ 7:
                    message.proofClient = reader.bytes();
                    break;
                case /* bytes proof_consensus */ 8:
                    message.proofConsensus = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height consensus_height */ 9:
                    message.consensusHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.consensusHeight);
                    break;
                case /* string signer */ 10:
                    message.signer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connection_id = 1; */
        if (message.connectionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectionId);
        /* string counterparty_connection_id = 2; */
        if (message.counterpartyConnectionId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.counterpartyConnectionId);
        /* ibc.core.connection.v1.Version version = 3; */
        if (message.version)
            Version.internalBinaryWrite(message.version, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any client_state = 4; */
        if (message.clientState)
            Any.internalBinaryWrite(message.clientState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height proof_height = 5; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bytes proof_try = 6; */
        if (message.proofTry.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.proofTry);
        /* bytes proof_client = 7; */
        if (message.proofClient.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.proofClient);
        /* bytes proof_consensus = 8; */
        if (message.proofConsensus.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.proofConsensus);
        /* ibc.core.client.v1.Height consensus_height = 9; */
        if (message.consensusHeight)
            Height.internalBinaryWrite(message.consensusHeight, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string signer = 10; */
        if (message.signer !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.signer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenAck
 */
export const MsgConnectionOpenAck = new MsgConnectionOpenAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenAckResponse$Type extends MessageType<MsgConnectionOpenAckResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenAckResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenAckResponse>): MsgConnectionOpenAckResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenAckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenAckResponse): MsgConnectionOpenAckResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgConnectionOpenAckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenAckResponse
 */
export const MsgConnectionOpenAckResponse = new MsgConnectionOpenAckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenConfirm$Type extends MessageType<MsgConnectionOpenConfirm> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenConfirm", [
            { no: 1, name: "connection_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "gogoproto.moretags": "yaml:\"connection_id\"" } },
            { no: 2, name: "proof_ack", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "gogoproto.moretags": "yaml:\"proof_ack\"" } },
            { no: 3, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false, "gogoproto.moretags": "yaml:\"proof_height\"" } },
            { no: 4, name: "signer", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false });
    }
    create(value?: PartialMessage<MsgConnectionOpenConfirm>): MsgConnectionOpenConfirm {
        const message = { connectionId: "", proofAck: new Uint8Array(0), signer: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenConfirm>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenConfirm): MsgConnectionOpenConfirm {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connection_id */ 1:
                    message.connectionId = reader.string();
                    break;
                case /* bytes proof_ack */ 2:
                    message.proofAck = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 3:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                case /* string signer */ 4:
                    message.signer = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgConnectionOpenConfirm, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connection_id = 1; */
        if (message.connectionId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connectionId);
        /* bytes proof_ack = 2; */
        if (message.proofAck.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proofAck);
        /* ibc.core.client.v1.Height proof_height = 3; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string signer = 4; */
        if (message.signer !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.signer);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirm
 */
export const MsgConnectionOpenConfirm = new MsgConnectionOpenConfirm$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgConnectionOpenConfirmResponse$Type extends MessageType<MsgConnectionOpenConfirmResponse> {
    constructor() {
        super("ibc.core.connection.v1.MsgConnectionOpenConfirmResponse", []);
    }
    create(value?: PartialMessage<MsgConnectionOpenConfirmResponse>): MsgConnectionOpenConfirmResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgConnectionOpenConfirmResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgConnectionOpenConfirmResponse): MsgConnectionOpenConfirmResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MsgConnectionOpenConfirmResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.MsgConnectionOpenConfirmResponse
 */
export const MsgConnectionOpenConfirmResponse = new MsgConnectionOpenConfirmResponse$Type();
/**
 * @generated ServiceType for protobuf service ibc.core.connection.v1.Msg
 */
export const Msg = new ServiceType("ibc.core.connection.v1.Msg", [
    { name: "ConnectionOpenInit", options: {}, I: MsgConnectionOpenInit, O: MsgConnectionOpenInitResponse },
    { name: "ConnectionOpenTry", options: {}, I: MsgConnectionOpenTry, O: MsgConnectionOpenTryResponse },
    { name: "ConnectionOpenAck", options: {}, I: MsgConnectionOpenAck, O: MsgConnectionOpenAckResponse },
    { name: "ConnectionOpenConfirm", options: {}, I: MsgConnectionOpenConfirm, O: MsgConnectionOpenConfirmResponse }
]);
