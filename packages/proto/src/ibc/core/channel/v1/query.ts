// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "ibc/core/channel/v1/query.proto" (package "ibc.core.channel.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PacketState } from "./channel";
import { Any } from "../../../../google/protobuf/any";
import { IdentifiedClientState } from "../../client/v1/client";
import { PageResponse } from "../../../../cosmos/base/query/v1beta1/pagination";
import { IdentifiedChannel } from "./channel";
import { PageRequest } from "../../../../cosmos/base/query/v1beta1/pagination";
import { Height } from "../../client/v1/client";
import { Channel } from "./channel";
/**
 * QueryChannelRequest is the request type for the Query/Channel RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelRequest
 */
export interface QueryChannelRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
}
/**
 * QueryChannelResponse is the response type for the Query/Channel RPC method.
 * Besides the Channel end, it includes a proof and the height from which the
 * proof was retrieved.
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelResponse
 */
export interface QueryChannelResponse {
    /**
     * channel associated with the request identifiers
     *
     * @generated from protobuf field: ibc.core.channel.v1.Channel channel = 1;
     */
    channel?: Channel;
    /**
     * merkle proof of existence
     *
     * @generated from protobuf field: bytes proof = 2;
     */
    proof: Uint8Array;
    /**
     * height at which the proof was retrieved
     *
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 3;
     */
    proofHeight?: Height;
}
/**
 * QueryChannelsRequest is the request type for the Query/Channels RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelsRequest
 */
export interface QueryChannelsRequest {
    /**
     * pagination request
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 1;
     */
    pagination?: PageRequest;
}
/**
 * QueryChannelsResponse is the response type for the Query/Channels RPC method.
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelsResponse
 */
export interface QueryChannelsResponse {
    /**
     * list of stored channels of the chain.
     *
     * @generated from protobuf field: repeated ibc.core.channel.v1.IdentifiedChannel channels = 1;
     */
    channels: IdentifiedChannel[];
    /**
     * pagination response
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
    /**
     * query block height
     *
     * @generated from protobuf field: ibc.core.client.v1.Height height = 3;
     */
    height?: Height;
}
/**
 * QueryConnectionChannelsRequest is the request type for the
 * Query/QueryConnectionChannels RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryConnectionChannelsRequest
 */
export interface QueryConnectionChannelsRequest {
    /**
     * connection unique identifier
     *
     * @generated from protobuf field: string connection = 1;
     */
    connection: string;
    /**
     * pagination request
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 2;
     */
    pagination?: PageRequest;
}
/**
 * QueryConnectionChannelsResponse is the Response type for the
 * Query/QueryConnectionChannels RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryConnectionChannelsResponse
 */
export interface QueryConnectionChannelsResponse {
    /**
     * list of channels associated with a connection.
     *
     * @generated from protobuf field: repeated ibc.core.channel.v1.IdentifiedChannel channels = 1;
     */
    channels: IdentifiedChannel[];
    /**
     * pagination response
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
    /**
     * query block height
     *
     * @generated from protobuf field: ibc.core.client.v1.Height height = 3;
     */
    height?: Height;
}
/**
 * QueryChannelClientStateRequest is the request type for the Query/ClientState
 * RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelClientStateRequest
 */
export interface QueryChannelClientStateRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
}
/**
 * QueryChannelClientStateResponse is the Response type for the
 * Query/QueryChannelClientState RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelClientStateResponse
 */
export interface QueryChannelClientStateResponse {
    /**
     * client state associated with the channel
     *
     * @generated from protobuf field: ibc.core.client.v1.IdentifiedClientState identified_client_state = 1;
     */
    identifiedClientState?: IdentifiedClientState;
    /**
     * merkle proof of existence
     *
     * @generated from protobuf field: bytes proof = 2;
     */
    proof: Uint8Array;
    /**
     * height at which the proof was retrieved
     *
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 3;
     */
    proofHeight?: Height;
}
/**
 * QueryChannelConsensusStateRequest is the request type for the
 * Query/ConsensusState RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelConsensusStateRequest
 */
export interface QueryChannelConsensusStateRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * revision number of the consensus state
     *
     * @generated from protobuf field: uint64 revision_number = 3;
     */
    revisionNumber: string;
    /**
     * revision height of the consensus state
     *
     * @generated from protobuf field: uint64 revision_height = 4;
     */
    revisionHeight: string;
}
/**
 * QueryChannelClientStateResponse is the Response type for the
 * Query/QueryChannelClientState RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryChannelConsensusStateResponse
 */
export interface QueryChannelConsensusStateResponse {
    /**
     * consensus state associated with the channel
     *
     * @generated from protobuf field: google.protobuf.Any consensus_state = 1;
     */
    consensusState?: Any;
    /**
     * client ID associated with the consensus state
     *
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * merkle proof of existence
     *
     * @generated from protobuf field: bytes proof = 3;
     */
    proof: Uint8Array;
    /**
     * height at which the proof was retrieved
     *
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 4;
     */
    proofHeight?: Height;
}
/**
 * QueryPacketCommitmentRequest is the request type for the
 * Query/PacketCommitment RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketCommitmentRequest
 */
export interface QueryPacketCommitmentRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * packet sequence
     *
     * @generated from protobuf field: uint64 sequence = 3;
     */
    sequence: string;
}
/**
 * QueryPacketCommitmentResponse defines the client query response for a packet
 * which also includes a proof and the height from which the proof was
 * retrieved
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketCommitmentResponse
 */
export interface QueryPacketCommitmentResponse {
    /**
     * packet associated with the request fields
     *
     * @generated from protobuf field: bytes commitment = 1;
     */
    commitment: Uint8Array;
    /**
     * merkle proof of existence
     *
     * @generated from protobuf field: bytes proof = 2;
     */
    proof: Uint8Array;
    /**
     * height at which the proof was retrieved
     *
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 3;
     */
    proofHeight?: Height;
}
/**
 * QueryPacketCommitmentsRequest is the request type for the
 * Query/QueryPacketCommitments RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketCommitmentsRequest
 */
export interface QueryPacketCommitmentsRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * pagination request
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 3;
     */
    pagination?: PageRequest;
}
/**
 * QueryPacketCommitmentsResponse is the request type for the
 * Query/QueryPacketCommitments RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketCommitmentsResponse
 */
export interface QueryPacketCommitmentsResponse {
    /**
     * @generated from protobuf field: repeated ibc.core.channel.v1.PacketState commitments = 1;
     */
    commitments: PacketState[];
    /**
     * pagination response
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
    /**
     * query block height
     *
     * @generated from protobuf field: ibc.core.client.v1.Height height = 3;
     */
    height?: Height;
}
/**
 * QueryPacketReceiptRequest is the request type for the
 * Query/PacketReceipt RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketReceiptRequest
 */
export interface QueryPacketReceiptRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * packet sequence
     *
     * @generated from protobuf field: uint64 sequence = 3;
     */
    sequence: string;
}
/**
 * QueryPacketReceiptResponse defines the client query response for a packet
 * receipt which also includes a proof, and the height from which the proof was
 * retrieved
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketReceiptResponse
 */
export interface QueryPacketReceiptResponse {
    /**
     * success flag for if receipt exists
     *
     * @generated from protobuf field: bool received = 2;
     */
    received: boolean;
    /**
     * merkle proof of existence
     *
     * @generated from protobuf field: bytes proof = 3;
     */
    proof: Uint8Array;
    /**
     * height at which the proof was retrieved
     *
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 4;
     */
    proofHeight?: Height;
}
/**
 * QueryPacketAcknowledgementRequest is the request type for the
 * Query/PacketAcknowledgement RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementRequest
 */
export interface QueryPacketAcknowledgementRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * packet sequence
     *
     * @generated from protobuf field: uint64 sequence = 3;
     */
    sequence: string;
}
/**
 * QueryPacketAcknowledgementResponse defines the client query response for a
 * packet which also includes a proof and the height from which the
 * proof was retrieved
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementResponse
 */
export interface QueryPacketAcknowledgementResponse {
    /**
     * packet associated with the request fields
     *
     * @generated from protobuf field: bytes acknowledgement = 1;
     */
    acknowledgement: Uint8Array;
    /**
     * merkle proof of existence
     *
     * @generated from protobuf field: bytes proof = 2;
     */
    proof: Uint8Array;
    /**
     * height at which the proof was retrieved
     *
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 3;
     */
    proofHeight?: Height;
}
/**
 * QueryPacketAcknowledgementsRequest is the request type for the
 * Query/QueryPacketCommitments RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementsRequest
 */
export interface QueryPacketAcknowledgementsRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * pagination request
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageRequest pagination = 3;
     */
    pagination?: PageRequest;
    /**
     * list of packet sequences
     *
     * @generated from protobuf field: repeated uint64 packet_commitment_sequences = 4;
     */
    packetCommitmentSequences: string[];
}
/**
 * QueryPacketAcknowledgemetsResponse is the request type for the
 * Query/QueryPacketAcknowledgements RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementsResponse
 */
export interface QueryPacketAcknowledgementsResponse {
    /**
     * @generated from protobuf field: repeated ibc.core.channel.v1.PacketState acknowledgements = 1;
     */
    acknowledgements: PacketState[];
    /**
     * pagination response
     *
     * @generated from protobuf field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
     */
    pagination?: PageResponse;
    /**
     * query block height
     *
     * @generated from protobuf field: ibc.core.client.v1.Height height = 3;
     */
    height?: Height;
}
/**
 * QueryUnreceivedPacketsRequest is the request type for the
 * Query/UnreceivedPackets RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryUnreceivedPacketsRequest
 */
export interface QueryUnreceivedPacketsRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * list of packet sequences
     *
     * @generated from protobuf field: repeated uint64 packet_commitment_sequences = 3;
     */
    packetCommitmentSequences: string[];
}
/**
 * QueryUnreceivedPacketsResponse is the response type for the
 * Query/UnreceivedPacketCommitments RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryUnreceivedPacketsResponse
 */
export interface QueryUnreceivedPacketsResponse {
    /**
     * list of unreceived packet sequences
     *
     * @generated from protobuf field: repeated uint64 sequences = 1;
     */
    sequences: string[];
    /**
     * query block height
     *
     * @generated from protobuf field: ibc.core.client.v1.Height height = 2;
     */
    height?: Height;
}
/**
 * QueryUnreceivedAcks is the request type for the
 * Query/UnreceivedAcks RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryUnreceivedAcksRequest
 */
export interface QueryUnreceivedAcksRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
    /**
     * list of acknowledgement sequences
     *
     * @generated from protobuf field: repeated uint64 packet_ack_sequences = 3;
     */
    packetAckSequences: string[];
}
/**
 * QueryUnreceivedAcksResponse is the response type for the
 * Query/UnreceivedAcks RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryUnreceivedAcksResponse
 */
export interface QueryUnreceivedAcksResponse {
    /**
     * list of unreceived acknowledgement sequences
     *
     * @generated from protobuf field: repeated uint64 sequences = 1;
     */
    sequences: string[];
    /**
     * query block height
     *
     * @generated from protobuf field: ibc.core.client.v1.Height height = 2;
     */
    height?: Height;
}
/**
 * QueryNextSequenceReceiveRequest is the request type for the
 * Query/QueryNextSequenceReceiveRequest RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryNextSequenceReceiveRequest
 */
export interface QueryNextSequenceReceiveRequest {
    /**
     * port unique identifier
     *
     * @generated from protobuf field: string port_id = 1;
     */
    portId: string;
    /**
     * channel unique identifier
     *
     * @generated from protobuf field: string channel_id = 2;
     */
    channelId: string;
}
/**
 * QuerySequenceResponse is the request type for the
 * Query/QueryNextSequenceReceiveResponse RPC method
 *
 * @generated from protobuf message ibc.core.channel.v1.QueryNextSequenceReceiveResponse
 */
export interface QueryNextSequenceReceiveResponse {
    /**
     * next sequence receive number
     *
     * @generated from protobuf field: uint64 next_sequence_receive = 1;
     */
    nextSequenceReceive: string;
    /**
     * merkle proof of existence
     *
     * @generated from protobuf field: bytes proof = 2;
     */
    proof: Uint8Array;
    /**
     * height at which the proof was retrieved
     *
     * @generated from protobuf field: ibc.core.client.v1.Height proof_height = 3;
     */
    proofHeight?: Height;
}
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelRequest$Type extends MessageType<QueryChannelRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryChannelRequest>): QueryChannelRequest {
        const message = { portId: "", channelId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelRequest): QueryChannelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelRequest
 */
export const QueryChannelRequest = new QueryChannelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelResponse$Type extends MessageType<QueryChannelResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelResponse", [
            { no: 1, name: "channel", kind: "message", T: () => Channel },
            { no: 2, name: "proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryChannelResponse>): QueryChannelResponse {
        const message = { proof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelResponse): QueryChannelResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ibc.core.channel.v1.Channel channel */ 1:
                    message.channel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.channel);
                    break;
                case /* bytes proof */ 2:
                    message.proof = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 3:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ibc.core.channel.v1.Channel channel = 1; */
        if (message.channel)
            Channel.internalBinaryWrite(message.channel, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes proof = 2; */
        if (message.proof.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proof);
        /* ibc.core.client.v1.Height proof_height = 3; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelResponse
 */
export const QueryChannelResponse = new QueryChannelResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelsRequest$Type extends MessageType<QueryChannelsRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelsRequest", [
            { no: 1, name: "pagination", kind: "message", T: () => PageRequest }
        ]);
    }
    create(value?: PartialMessage<QueryChannelsRequest>): QueryChannelsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelsRequest): QueryChannelsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 1:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.query.v1beta1.PageRequest pagination = 1; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelsRequest
 */
export const QueryChannelsRequest = new QueryChannelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelsResponse$Type extends MessageType<QueryChannelsResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelsResponse", [
            { no: 1, name: "channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IdentifiedChannel },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse },
            { no: 3, name: "height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryChannelsResponse>): QueryChannelsResponse {
        const message = { channels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelsResponse): QueryChannelsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ibc.core.channel.v1.IdentifiedChannel channels */ 1:
                    message.channels.push(IdentifiedChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* ibc.core.client.v1.Height height */ 3:
                    message.height = Height.internalBinaryRead(reader, reader.uint32(), options, message.height);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ibc.core.channel.v1.IdentifiedChannel channels = 1; */
        for (let i = 0; i < message.channels.length; i++)
            IdentifiedChannel.internalBinaryWrite(message.channels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height height = 3; */
        if (message.height)
            Height.internalBinaryWrite(message.height, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelsResponse
 */
export const QueryChannelsResponse = new QueryChannelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryConnectionChannelsRequest$Type extends MessageType<QueryConnectionChannelsRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryConnectionChannelsRequest", [
            { no: 1, name: "connection", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pagination", kind: "message", T: () => PageRequest }
        ]);
    }
    create(value?: PartialMessage<QueryConnectionChannelsRequest>): QueryConnectionChannelsRequest {
        const message = { connection: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryConnectionChannelsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryConnectionChannelsRequest): QueryConnectionChannelsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string connection */ 1:
                    message.connection = reader.string();
                    break;
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 2:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryConnectionChannelsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string connection = 1; */
        if (message.connection !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.connection);
        /* cosmos.base.query.v1beta1.PageRequest pagination = 2; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryConnectionChannelsRequest
 */
export const QueryConnectionChannelsRequest = new QueryConnectionChannelsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryConnectionChannelsResponse$Type extends MessageType<QueryConnectionChannelsResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryConnectionChannelsResponse", [
            { no: 1, name: "channels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => IdentifiedChannel },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse },
            { no: 3, name: "height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryConnectionChannelsResponse>): QueryConnectionChannelsResponse {
        const message = { channels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryConnectionChannelsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryConnectionChannelsResponse): QueryConnectionChannelsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ibc.core.channel.v1.IdentifiedChannel channels */ 1:
                    message.channels.push(IdentifiedChannel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* ibc.core.client.v1.Height height */ 3:
                    message.height = Height.internalBinaryRead(reader, reader.uint32(), options, message.height);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryConnectionChannelsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ibc.core.channel.v1.IdentifiedChannel channels = 1; */
        for (let i = 0; i < message.channels.length; i++)
            IdentifiedChannel.internalBinaryWrite(message.channels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height height = 3; */
        if (message.height)
            Height.internalBinaryWrite(message.height, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryConnectionChannelsResponse
 */
export const QueryConnectionChannelsResponse = new QueryConnectionChannelsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelClientStateRequest$Type extends MessageType<QueryChannelClientStateRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelClientStateRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryChannelClientStateRequest>): QueryChannelClientStateRequest {
        const message = { portId: "", channelId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelClientStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelClientStateRequest): QueryChannelClientStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelClientStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelClientStateRequest
 */
export const QueryChannelClientStateRequest = new QueryChannelClientStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelClientStateResponse$Type extends MessageType<QueryChannelClientStateResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelClientStateResponse", [
            { no: 1, name: "identified_client_state", kind: "message", T: () => IdentifiedClientState },
            { no: 2, name: "proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryChannelClientStateResponse>): QueryChannelClientStateResponse {
        const message = { proof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelClientStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelClientStateResponse): QueryChannelClientStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ibc.core.client.v1.IdentifiedClientState identified_client_state */ 1:
                    message.identifiedClientState = IdentifiedClientState.internalBinaryRead(reader, reader.uint32(), options, message.identifiedClientState);
                    break;
                case /* bytes proof */ 2:
                    message.proof = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 3:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelClientStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ibc.core.client.v1.IdentifiedClientState identified_client_state = 1; */
        if (message.identifiedClientState)
            IdentifiedClientState.internalBinaryWrite(message.identifiedClientState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes proof = 2; */
        if (message.proof.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proof);
        /* ibc.core.client.v1.Height proof_height = 3; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelClientStateResponse
 */
export const QueryChannelClientStateResponse = new QueryChannelClientStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelConsensusStateRequest$Type extends MessageType<QueryChannelConsensusStateRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelConsensusStateRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "revision_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "revision_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryChannelConsensusStateRequest>): QueryChannelConsensusStateRequest {
        const message = { portId: "", channelId: "", revisionNumber: "0", revisionHeight: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelConsensusStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelConsensusStateRequest): QueryChannelConsensusStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* uint64 revision_number */ 3:
                    message.revisionNumber = reader.uint64().toString();
                    break;
                case /* uint64 revision_height */ 4:
                    message.revisionHeight = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelConsensusStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* uint64 revision_number = 3; */
        if (message.revisionNumber !== "0")
            writer.tag(3, WireType.Varint).uint64(message.revisionNumber);
        /* uint64 revision_height = 4; */
        if (message.revisionHeight !== "0")
            writer.tag(4, WireType.Varint).uint64(message.revisionHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelConsensusStateRequest
 */
export const QueryChannelConsensusStateRequest = new QueryChannelConsensusStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryChannelConsensusStateResponse$Type extends MessageType<QueryChannelConsensusStateResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryChannelConsensusStateResponse", [
            { no: 1, name: "consensus_state", kind: "message", T: () => Any },
            { no: 2, name: "client_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryChannelConsensusStateResponse>): QueryChannelConsensusStateResponse {
        const message = { clientId: "", proof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryChannelConsensusStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryChannelConsensusStateResponse): QueryChannelConsensusStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any consensus_state */ 1:
                    message.consensusState = Any.internalBinaryRead(reader, reader.uint32(), options, message.consensusState);
                    break;
                case /* string client_id */ 2:
                    message.clientId = reader.string();
                    break;
                case /* bytes proof */ 3:
                    message.proof = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 4:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryChannelConsensusStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any consensus_state = 1; */
        if (message.consensusState)
            Any.internalBinaryWrite(message.consensusState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string client_id = 2; */
        if (message.clientId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.clientId);
        /* bytes proof = 3; */
        if (message.proof.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.proof);
        /* ibc.core.client.v1.Height proof_height = 4; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryChannelConsensusStateResponse
 */
export const QueryChannelConsensusStateResponse = new QueryChannelConsensusStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketCommitmentRequest$Type extends MessageType<QueryPacketCommitmentRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketCommitmentRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPacketCommitmentRequest>): QueryPacketCommitmentRequest {
        const message = { portId: "", channelId: "", sequence: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketCommitmentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketCommitmentRequest): QueryPacketCommitmentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketCommitmentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* uint64 sequence = 3; */
        if (message.sequence !== "0")
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketCommitmentRequest
 */
export const QueryPacketCommitmentRequest = new QueryPacketCommitmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketCommitmentResponse$Type extends MessageType<QueryPacketCommitmentResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketCommitmentResponse", [
            { no: 1, name: "commitment", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPacketCommitmentResponse>): QueryPacketCommitmentResponse {
        const message = { commitment: new Uint8Array(0), proof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketCommitmentResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketCommitmentResponse): QueryPacketCommitmentResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes commitment */ 1:
                    message.commitment = reader.bytes();
                    break;
                case /* bytes proof */ 2:
                    message.proof = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 3:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketCommitmentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes commitment = 1; */
        if (message.commitment.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.commitment);
        /* bytes proof = 2; */
        if (message.proof.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proof);
        /* ibc.core.client.v1.Height proof_height = 3; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketCommitmentResponse
 */
export const QueryPacketCommitmentResponse = new QueryPacketCommitmentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketCommitmentsRequest$Type extends MessageType<QueryPacketCommitmentsRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketCommitmentsRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pagination", kind: "message", T: () => PageRequest }
        ]);
    }
    create(value?: PartialMessage<QueryPacketCommitmentsRequest>): QueryPacketCommitmentsRequest {
        const message = { portId: "", channelId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketCommitmentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketCommitmentsRequest): QueryPacketCommitmentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 3:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketCommitmentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* cosmos.base.query.v1beta1.PageRequest pagination = 3; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketCommitmentsRequest
 */
export const QueryPacketCommitmentsRequest = new QueryPacketCommitmentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketCommitmentsResponse$Type extends MessageType<QueryPacketCommitmentsResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketCommitmentsResponse", [
            { no: 1, name: "commitments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PacketState },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse },
            { no: 3, name: "height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPacketCommitmentsResponse>): QueryPacketCommitmentsResponse {
        const message = { commitments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketCommitmentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketCommitmentsResponse): QueryPacketCommitmentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ibc.core.channel.v1.PacketState commitments */ 1:
                    message.commitments.push(PacketState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* ibc.core.client.v1.Height height */ 3:
                    message.height = Height.internalBinaryRead(reader, reader.uint32(), options, message.height);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketCommitmentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ibc.core.channel.v1.PacketState commitments = 1; */
        for (let i = 0; i < message.commitments.length; i++)
            PacketState.internalBinaryWrite(message.commitments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height height = 3; */
        if (message.height)
            Height.internalBinaryWrite(message.height, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketCommitmentsResponse
 */
export const QueryPacketCommitmentsResponse = new QueryPacketCommitmentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketReceiptRequest$Type extends MessageType<QueryPacketReceiptRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketReceiptRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPacketReceiptRequest>): QueryPacketReceiptRequest {
        const message = { portId: "", channelId: "", sequence: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketReceiptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketReceiptRequest): QueryPacketReceiptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketReceiptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* uint64 sequence = 3; */
        if (message.sequence !== "0")
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketReceiptRequest
 */
export const QueryPacketReceiptRequest = new QueryPacketReceiptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketReceiptResponse$Type extends MessageType<QueryPacketReceiptResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketReceiptResponse", [
            { no: 2, name: "received", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPacketReceiptResponse>): QueryPacketReceiptResponse {
        const message = { received: false, proof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketReceiptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketReceiptResponse): QueryPacketReceiptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool received */ 2:
                    message.received = reader.bool();
                    break;
                case /* bytes proof */ 3:
                    message.proof = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 4:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketReceiptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool received = 2; */
        if (message.received !== false)
            writer.tag(2, WireType.Varint).bool(message.received);
        /* bytes proof = 3; */
        if (message.proof.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.proof);
        /* ibc.core.client.v1.Height proof_height = 4; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketReceiptResponse
 */
export const QueryPacketReceiptResponse = new QueryPacketReceiptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketAcknowledgementRequest$Type extends MessageType<QueryPacketAcknowledgementRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketAcknowledgementRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPacketAcknowledgementRequest>): QueryPacketAcknowledgementRequest {
        const message = { portId: "", channelId: "", sequence: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketAcknowledgementRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketAcknowledgementRequest): QueryPacketAcknowledgementRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketAcknowledgementRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* uint64 sequence = 3; */
        if (message.sequence !== "0")
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementRequest
 */
export const QueryPacketAcknowledgementRequest = new QueryPacketAcknowledgementRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketAcknowledgementResponse$Type extends MessageType<QueryPacketAcknowledgementResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketAcknowledgementResponse", [
            { no: 1, name: "acknowledgement", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPacketAcknowledgementResponse>): QueryPacketAcknowledgementResponse {
        const message = { acknowledgement: new Uint8Array(0), proof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketAcknowledgementResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketAcknowledgementResponse): QueryPacketAcknowledgementResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes acknowledgement */ 1:
                    message.acknowledgement = reader.bytes();
                    break;
                case /* bytes proof */ 2:
                    message.proof = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 3:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketAcknowledgementResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes acknowledgement = 1; */
        if (message.acknowledgement.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.acknowledgement);
        /* bytes proof = 2; */
        if (message.proof.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proof);
        /* ibc.core.client.v1.Height proof_height = 3; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementResponse
 */
export const QueryPacketAcknowledgementResponse = new QueryPacketAcknowledgementResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketAcknowledgementsRequest$Type extends MessageType<QueryPacketAcknowledgementsRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketAcknowledgementsRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pagination", kind: "message", T: () => PageRequest },
            { no: 4, name: "packet_commitment_sequences", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryPacketAcknowledgementsRequest>): QueryPacketAcknowledgementsRequest {
        const message = { portId: "", channelId: "", packetCommitmentSequences: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketAcknowledgementsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketAcknowledgementsRequest): QueryPacketAcknowledgementsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* cosmos.base.query.v1beta1.PageRequest pagination */ 3:
                    message.pagination = PageRequest.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* repeated uint64 packet_commitment_sequences */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packetCommitmentSequences.push(reader.uint64().toString());
                    else
                        message.packetCommitmentSequences.push(reader.uint64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketAcknowledgementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* cosmos.base.query.v1beta1.PageRequest pagination = 3; */
        if (message.pagination)
            PageRequest.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint64 packet_commitment_sequences = 4; */
        if (message.packetCommitmentSequences.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packetCommitmentSequences.length; i++)
                writer.uint64(message.packetCommitmentSequences[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementsRequest
 */
export const QueryPacketAcknowledgementsRequest = new QueryPacketAcknowledgementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryPacketAcknowledgementsResponse$Type extends MessageType<QueryPacketAcknowledgementsResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryPacketAcknowledgementsResponse", [
            { no: 1, name: "acknowledgements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PacketState },
            { no: 2, name: "pagination", kind: "message", T: () => PageResponse },
            { no: 3, name: "height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryPacketAcknowledgementsResponse>): QueryPacketAcknowledgementsResponse {
        const message = { acknowledgements: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryPacketAcknowledgementsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryPacketAcknowledgementsResponse): QueryPacketAcknowledgementsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ibc.core.channel.v1.PacketState acknowledgements */ 1:
                    message.acknowledgements.push(PacketState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.base.query.v1beta1.PageResponse pagination */ 2:
                    message.pagination = PageResponse.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* ibc.core.client.v1.Height height */ 3:
                    message.height = Height.internalBinaryRead(reader, reader.uint32(), options, message.height);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryPacketAcknowledgementsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ibc.core.channel.v1.PacketState acknowledgements = 1; */
        for (let i = 0; i < message.acknowledgements.length; i++)
            PacketState.internalBinaryWrite(message.acknowledgements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.query.v1beta1.PageResponse pagination = 2; */
        if (message.pagination)
            PageResponse.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ibc.core.client.v1.Height height = 3; */
        if (message.height)
            Height.internalBinaryWrite(message.height, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryPacketAcknowledgementsResponse
 */
export const QueryPacketAcknowledgementsResponse = new QueryPacketAcknowledgementsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryUnreceivedPacketsRequest$Type extends MessageType<QueryUnreceivedPacketsRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryUnreceivedPacketsRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "packet_commitment_sequences", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryUnreceivedPacketsRequest>): QueryUnreceivedPacketsRequest {
        const message = { portId: "", channelId: "", packetCommitmentSequences: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryUnreceivedPacketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryUnreceivedPacketsRequest): QueryUnreceivedPacketsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* repeated uint64 packet_commitment_sequences */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packetCommitmentSequences.push(reader.uint64().toString());
                    else
                        message.packetCommitmentSequences.push(reader.uint64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryUnreceivedPacketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* repeated uint64 packet_commitment_sequences = 3; */
        if (message.packetCommitmentSequences.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packetCommitmentSequences.length; i++)
                writer.uint64(message.packetCommitmentSequences[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryUnreceivedPacketsRequest
 */
export const QueryUnreceivedPacketsRequest = new QueryUnreceivedPacketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryUnreceivedPacketsResponse$Type extends MessageType<QueryUnreceivedPacketsResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryUnreceivedPacketsResponse", [
            { no: 1, name: "sequences", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryUnreceivedPacketsResponse>): QueryUnreceivedPacketsResponse {
        const message = { sequences: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryUnreceivedPacketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryUnreceivedPacketsResponse): QueryUnreceivedPacketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 sequences */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sequences.push(reader.uint64().toString());
                    else
                        message.sequences.push(reader.uint64().toString());
                    break;
                case /* ibc.core.client.v1.Height height */ 2:
                    message.height = Height.internalBinaryRead(reader, reader.uint32(), options, message.height);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryUnreceivedPacketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 sequences = 1; */
        if (message.sequences.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sequences.length; i++)
                writer.uint64(message.sequences[i]);
            writer.join();
        }
        /* ibc.core.client.v1.Height height = 2; */
        if (message.height)
            Height.internalBinaryWrite(message.height, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryUnreceivedPacketsResponse
 */
export const QueryUnreceivedPacketsResponse = new QueryUnreceivedPacketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryUnreceivedAcksRequest$Type extends MessageType<QueryUnreceivedAcksRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryUnreceivedAcksRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "packet_ack_sequences", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<QueryUnreceivedAcksRequest>): QueryUnreceivedAcksRequest {
        const message = { portId: "", channelId: "", packetAckSequences: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryUnreceivedAcksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryUnreceivedAcksRequest): QueryUnreceivedAcksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                case /* repeated uint64 packet_ack_sequences */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.packetAckSequences.push(reader.uint64().toString());
                    else
                        message.packetAckSequences.push(reader.uint64().toString());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryUnreceivedAcksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        /* repeated uint64 packet_ack_sequences = 3; */
        if (message.packetAckSequences.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.packetAckSequences.length; i++)
                writer.uint64(message.packetAckSequences[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryUnreceivedAcksRequest
 */
export const QueryUnreceivedAcksRequest = new QueryUnreceivedAcksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryUnreceivedAcksResponse$Type extends MessageType<QueryUnreceivedAcksResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryUnreceivedAcksResponse", [
            { no: 1, name: "sequences", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryUnreceivedAcksResponse>): QueryUnreceivedAcksResponse {
        const message = { sequences: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryUnreceivedAcksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryUnreceivedAcksResponse): QueryUnreceivedAcksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 sequences */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sequences.push(reader.uint64().toString());
                    else
                        message.sequences.push(reader.uint64().toString());
                    break;
                case /* ibc.core.client.v1.Height height */ 2:
                    message.height = Height.internalBinaryRead(reader, reader.uint32(), options, message.height);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryUnreceivedAcksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 sequences = 1; */
        if (message.sequences.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sequences.length; i++)
                writer.uint64(message.sequences[i]);
            writer.join();
        }
        /* ibc.core.client.v1.Height height = 2; */
        if (message.height)
            Height.internalBinaryWrite(message.height, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryUnreceivedAcksResponse
 */
export const QueryUnreceivedAcksResponse = new QueryUnreceivedAcksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryNextSequenceReceiveRequest$Type extends MessageType<QueryNextSequenceReceiveRequest> {
    constructor() {
        super("ibc.core.channel.v1.QueryNextSequenceReceiveRequest", [
            { no: 1, name: "port_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "channel_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryNextSequenceReceiveRequest>): QueryNextSequenceReceiveRequest {
        const message = { portId: "", channelId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryNextSequenceReceiveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryNextSequenceReceiveRequest): QueryNextSequenceReceiveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string port_id */ 1:
                    message.portId = reader.string();
                    break;
                case /* string channel_id */ 2:
                    message.channelId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryNextSequenceReceiveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string port_id = 1; */
        if (message.portId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.portId);
        /* string channel_id = 2; */
        if (message.channelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.channelId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryNextSequenceReceiveRequest
 */
export const QueryNextSequenceReceiveRequest = new QueryNextSequenceReceiveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryNextSequenceReceiveResponse$Type extends MessageType<QueryNextSequenceReceiveResponse> {
    constructor() {
        super("ibc.core.channel.v1.QueryNextSequenceReceiveResponse", [
            { no: 1, name: "next_sequence_receive", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "proof", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "proof_height", kind: "message", T: () => Height, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value?: PartialMessage<QueryNextSequenceReceiveResponse>): QueryNextSequenceReceiveResponse {
        const message = { nextSequenceReceive: "0", proof: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryNextSequenceReceiveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryNextSequenceReceiveResponse): QueryNextSequenceReceiveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 next_sequence_receive */ 1:
                    message.nextSequenceReceive = reader.uint64().toString();
                    break;
                case /* bytes proof */ 2:
                    message.proof = reader.bytes();
                    break;
                case /* ibc.core.client.v1.Height proof_height */ 3:
                    message.proofHeight = Height.internalBinaryRead(reader, reader.uint32(), options, message.proofHeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryNextSequenceReceiveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 next_sequence_receive = 1; */
        if (message.nextSequenceReceive !== "0")
            writer.tag(1, WireType.Varint).uint64(message.nextSequenceReceive);
        /* bytes proof = 2; */
        if (message.proof.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.proof);
        /* ibc.core.client.v1.Height proof_height = 3; */
        if (message.proofHeight)
            Height.internalBinaryWrite(message.proofHeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ibc.core.channel.v1.QueryNextSequenceReceiveResponse
 */
export const QueryNextSequenceReceiveResponse = new QueryNextSequenceReceiveResponse$Type();
/**
 * @generated ServiceType for protobuf service ibc.core.channel.v1.Query
 */
export const Query = new ServiceType("ibc.core.channel.v1.Query", [
    { name: "Channel", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}" } }, I: QueryChannelRequest, O: QueryChannelResponse },
    { name: "Channels", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels" } }, I: QueryChannelsRequest, O: QueryChannelsResponse },
    { name: "ConnectionChannels", options: { "google.api.http": { get: "/ibc/core/channel/v1/connections/{connection}/channels" } }, I: QueryConnectionChannelsRequest, O: QueryConnectionChannelsResponse },
    { name: "ChannelClientState", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state" } }, I: QueryChannelClientStateRequest, O: QueryChannelClientStateResponse },
    { name: "ChannelConsensusState", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}" } }, I: QueryChannelConsensusStateRequest, O: QueryChannelConsensusStateResponse },
    { name: "PacketCommitment", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}" } }, I: QueryPacketCommitmentRequest, O: QueryPacketCommitmentResponse },
    { name: "PacketCommitments", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments" } }, I: QueryPacketCommitmentsRequest, O: QueryPacketCommitmentsResponse },
    { name: "PacketReceipt", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}" } }, I: QueryPacketReceiptRequest, O: QueryPacketReceiptResponse },
    { name: "PacketAcknowledgement", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}" } }, I: QueryPacketAcknowledgementRequest, O: QueryPacketAcknowledgementResponse },
    { name: "PacketAcknowledgements", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements" } }, I: QueryPacketAcknowledgementsRequest, O: QueryPacketAcknowledgementsResponse },
    { name: "UnreceivedPackets", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets" } }, I: QueryUnreceivedPacketsRequest, O: QueryUnreceivedPacketsResponse },
    { name: "UnreceivedAcks", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks" } }, I: QueryUnreceivedAcksRequest, O: QueryUnreceivedAcksResponse },
    { name: "NextSequenceReceive", options: { "google.api.http": { get: "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence" } }, I: QueryNextSequenceReceiveRequest, O: QueryNextSequenceReceiveResponse }
]);
