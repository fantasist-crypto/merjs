// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "cosmos/tx/v1beta1/tx.proto" (package "cosmos.tx.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../base/v1beta1/coin";
import { CompactBitArray } from "../../crypto/multisig/v1beta1/multisig";
import { SignMode } from "../signing/v1beta1/signing";
import { Any } from "../../../google/protobuf/any";
/**
 * Tx is the standard type used for broadcasting transactions.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.Tx
 */
export interface Tx {
    /**
     * body is the processable content of the transaction
     *
     * @generated from protobuf field: cosmos.tx.v1beta1.TxBody body = 1;
     */
    body?: TxBody;
    /**
     * auth_info is the authorization related content of the transaction,
     * specifically signers, signer modes and fee
     *
     * @generated from protobuf field: cosmos.tx.v1beta1.AuthInfo auth_info = 2;
     */
    authInfo?: AuthInfo;
    /**
     * signatures is a list of signatures that matches the length and order of
     * AuthInfo's signer_infos to allow connecting signature meta information like
     * public key and signing mode by position.
     *
     * @generated from protobuf field: repeated bytes signatures = 3;
     */
    signatures: Uint8Array[];
}
/**
 * TxRaw is a variant of Tx that pins the signer's exact binary representation
 * of body and auth_info. This is used for signing, broadcasting and
 * verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
 * the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
 * as the transaction ID.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.TxRaw
 */
export interface TxRaw {
    /**
     * body_bytes is a protobuf serialization of a TxBody that matches the
     * representation in SignDoc.
     *
     * @generated from protobuf field: bytes body_bytes = 1;
     */
    bodyBytes: Uint8Array;
    /**
     * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
     * representation in SignDoc.
     *
     * @generated from protobuf field: bytes auth_info_bytes = 2;
     */
    authInfoBytes: Uint8Array;
    /**
     * signatures is a list of signatures that matches the length and order of
     * AuthInfo's signer_infos to allow connecting signature meta information like
     * public key and signing mode by position.
     *
     * @generated from protobuf field: repeated bytes signatures = 3;
     */
    signatures: Uint8Array[];
}
/**
 * SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.SignDoc
 */
export interface SignDoc {
    /**
     * body_bytes is protobuf serialization of a TxBody that matches the
     * representation in TxRaw.
     *
     * @generated from protobuf field: bytes body_bytes = 1;
     */
    bodyBytes: Uint8Array;
    /**
     * auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
     * representation in TxRaw.
     *
     * @generated from protobuf field: bytes auth_info_bytes = 2;
     */
    authInfoBytes: Uint8Array;
    /**
     * chain_id is the unique identifier of the chain this transaction targets.
     * It prevents signed transactions from being used on another chain by an
     * attacker
     *
     * @generated from protobuf field: string chain_id = 3;
     */
    chainId: string;
    /**
     * account_number is the account number of the account in state
     *
     * @generated from protobuf field: uint64 account_number = 4;
     */
    accountNumber: string;
}
/**
 * TxBody is the body of a transaction that all signers sign over.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.TxBody
 */
export interface TxBody {
    /**
     * messages is a list of messages to be executed. The required signers of
     * those messages define the number and order of elements in AuthInfo's
     * signer_infos and Tx's signatures. Each required signer address is added to
     * the list only the first time it occurs.
     * By convention, the first required signer (usually from the first message)
     * is referred to as the primary signer and pays the fee for the whole
     * transaction.
     *
     * @generated from protobuf field: repeated google.protobuf.Any messages = 1;
     */
    messages: Any[];
    /**
     * memo is any arbitrary note/comment to be added to the transaction.
     * WARNING: in clients, any publicly exposed text should not be called memo,
     * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
     *
     * @generated from protobuf field: string memo = 2;
     */
    memo: string;
    /**
     * timeout is the block height after which this transaction will not
     * be processed by the chain
     *
     * @generated from protobuf field: uint64 timeout_height = 3;
     */
    timeoutHeight: string;
    /**
     * extension_options are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, the transaction will be rejected
     *
     * @generated from protobuf field: repeated google.protobuf.Any extension_options = 1023;
     */
    extensionOptions: Any[];
    /**
     * extension_options are arbitrary options that can be added by chains
     * when the default options are not sufficient. If any of these are present
     * and can't be handled, they will be ignored
     *
     * @generated from protobuf field: repeated google.protobuf.Any non_critical_extension_options = 2047;
     */
    nonCriticalExtensionOptions: Any[];
}
/**
 * AuthInfo describes the fee and signer modes that are used to sign a
 * transaction.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.AuthInfo
 */
export interface AuthInfo {
    /**
     * signer_infos defines the signing modes for the required signers. The number
     * and order of elements must match the required signers from TxBody's
     * messages. The first element is the primary signer and the one which pays
     * the fee.
     *
     * @generated from protobuf field: repeated cosmos.tx.v1beta1.SignerInfo signer_infos = 1;
     */
    signerInfos: SignerInfo[];
    /**
     * Fee is the fee and gas limit for the transaction. The first signer is the
     * primary signer and the one which pays the fee. The fee can be calculated
     * based on the cost of evaluating the body and doing signature verification
     * of the signers. This can be estimated via simulation.
     *
     * @generated from protobuf field: cosmos.tx.v1beta1.Fee fee = 2;
     */
    fee?: Fee;
}
/**
 * SignerInfo describes the public key and signing mode of a single top-level
 * signer.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.SignerInfo
 */
export interface SignerInfo {
    /**
     * public_key is the public key of the signer. It is optional for accounts
     * that already exist in state. If unset, the verifier can use the required \
     * signer address for this position and lookup the public key.
     *
     * @generated from protobuf field: google.protobuf.Any public_key = 1;
     */
    publicKey?: Any;
    /**
     * mode_info describes the signing mode of the signer and is a nested
     * structure to support nested multisig pubkey's
     *
     * @generated from protobuf field: cosmos.tx.v1beta1.ModeInfo mode_info = 2;
     */
    modeInfo?: ModeInfo;
    /**
     * sequence is the sequence of the account, which describes the
     * number of committed transactions signed by a given address. It is used to
     * prevent replay attacks.
     *
     * @generated from protobuf field: uint64 sequence = 3;
     */
    sequence: string;
}
/**
 * ModeInfo describes the signing mode of a single or nested multisig signer.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.ModeInfo
 */
export interface ModeInfo {
    /**
     * @generated from protobuf oneof: sum
     */
    sum: {
        oneofKind: "single";
        /**
         * single represents a single signer
         *
         * @generated from protobuf field: cosmos.tx.v1beta1.ModeInfo.Single single = 1;
         */
        single: ModeInfo_Single;
    } | {
        oneofKind: "multi";
        /**
         * multi represents a nested multisig signer
         *
         * @generated from protobuf field: cosmos.tx.v1beta1.ModeInfo.Multi multi = 2;
         */
        multi: ModeInfo_Multi;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Single is the mode info for a single signer. It is structured as a message
 * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
 * future
 *
 * @generated from protobuf message cosmos.tx.v1beta1.ModeInfo.Single
 */
export interface ModeInfo_Single {
    /**
     * mode is the signing mode of the single signer
     *
     * @generated from protobuf field: cosmos.tx.signing.v1beta1.SignMode mode = 1;
     */
    mode: SignMode;
}
/**
 * Multi is the mode info for a multisig public key
 *
 * @generated from protobuf message cosmos.tx.v1beta1.ModeInfo.Multi
 */
export interface ModeInfo_Multi {
    /**
     * bitarray specifies which keys within the multisig are signing
     *
     * @generated from protobuf field: cosmos.crypto.multisig.v1beta1.CompactBitArray bitarray = 1;
     */
    bitarray?: CompactBitArray;
    /**
     * mode_infos is the corresponding modes of the signers of the multisig
     * which could include nested multisig public keys
     *
     * @generated from protobuf field: repeated cosmos.tx.v1beta1.ModeInfo mode_infos = 2;
     */
    modeInfos: ModeInfo[];
}
/**
 * Fee includes the amount of coins paid in fees and the maximum
 * gas to be used by the transaction. The ratio yields an effective "gasprice",
 * which must be above some miminum to be accepted into the mempool.
 *
 * @generated from protobuf message cosmos.tx.v1beta1.Fee
 */
export interface Fee {
    /**
     * amount is the amount of coins to be paid as a fee
     *
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 1;
     */
    amount: Coin[];
    /**
     * gas_limit is the maximum gas that can be used in transaction processing
     * before an out of gas error occurs
     *
     * @generated from protobuf field: uint64 gas_limit = 2;
     */
    gasLimit: string;
    /**
     * if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
     * the payer must be a tx signer (and thus have signed this field in AuthInfo).
     * setting this field does *not* change the ordering of required signers for the transaction.
     *
     * @generated from protobuf field: string payer = 3;
     */
    payer: string;
    /**
     * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
     * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
     * not support fee grants, this will fail
     *
     * @generated from protobuf field: string granter = 4;
     */
    granter: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Tx$Type extends MessageType<Tx> {
    constructor() {
        super("cosmos.tx.v1beta1.Tx", [
            { no: 1, name: "body", kind: "message", T: () => TxBody },
            { no: 2, name: "auth_info", kind: "message", T: () => AuthInfo },
            { no: 3, name: "signatures", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Tx>): Tx {
        const message = { signatures: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tx>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tx): Tx {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.tx.v1beta1.TxBody body */ 1:
                    message.body = TxBody.internalBinaryRead(reader, reader.uint32(), options, message.body);
                    break;
                case /* cosmos.tx.v1beta1.AuthInfo auth_info */ 2:
                    message.authInfo = AuthInfo.internalBinaryRead(reader, reader.uint32(), options, message.authInfo);
                    break;
                case /* repeated bytes signatures */ 3:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tx, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.tx.v1beta1.TxBody body = 1; */
        if (message.body)
            TxBody.internalBinaryWrite(message.body, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.tx.v1beta1.AuthInfo auth_info = 2; */
        if (message.authInfo)
            AuthInfo.internalBinaryWrite(message.authInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes signatures = 3; */
        for (let i = 0; i < message.signatures.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signatures[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.Tx
 */
export const Tx = new Tx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxRaw$Type extends MessageType<TxRaw> {
    constructor() {
        super("cosmos.tx.v1beta1.TxRaw", [
            { no: 1, name: "body_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "auth_info_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signatures", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TxRaw>): TxRaw {
        const message = { bodyBytes: new Uint8Array(0), authInfoBytes: new Uint8Array(0), signatures: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxRaw>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxRaw): TxRaw {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes body_bytes */ 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case /* bytes auth_info_bytes */ 2:
                    message.authInfoBytes = reader.bytes();
                    break;
                case /* repeated bytes signatures */ 3:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxRaw, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes body_bytes = 1; */
        if (message.bodyBytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.bodyBytes);
        /* bytes auth_info_bytes = 2; */
        if (message.authInfoBytes.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.authInfoBytes);
        /* repeated bytes signatures = 3; */
        for (let i = 0; i < message.signatures.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signatures[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.TxRaw
 */
export const TxRaw = new TxRaw$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignDoc$Type extends MessageType<SignDoc> {
    constructor() {
        super("cosmos.tx.v1beta1.SignDoc", [
            { no: 1, name: "body_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "auth_info_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "account_number", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<SignDoc>): SignDoc {
        const message = { bodyBytes: new Uint8Array(0), authInfoBytes: new Uint8Array(0), chainId: "", accountNumber: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignDoc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignDoc): SignDoc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes body_bytes */ 1:
                    message.bodyBytes = reader.bytes();
                    break;
                case /* bytes auth_info_bytes */ 2:
                    message.authInfoBytes = reader.bytes();
                    break;
                case /* string chain_id */ 3:
                    message.chainId = reader.string();
                    break;
                case /* uint64 account_number */ 4:
                    message.accountNumber = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignDoc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes body_bytes = 1; */
        if (message.bodyBytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.bodyBytes);
        /* bytes auth_info_bytes = 2; */
        if (message.authInfoBytes.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.authInfoBytes);
        /* string chain_id = 3; */
        if (message.chainId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.chainId);
        /* uint64 account_number = 4; */
        if (message.accountNumber !== "0")
            writer.tag(4, WireType.Varint).uint64(message.accountNumber);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.SignDoc
 */
export const SignDoc = new SignDoc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxBody$Type extends MessageType<TxBody> {
    constructor() {
        super("cosmos.tx.v1beta1.TxBody", [
            { no: 1, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 2, name: "memo", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timeout_height", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 1023, name: "extension_options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 2047, name: "non_critical_extension_options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any }
        ]);
    }
    create(value?: PartialMessage<TxBody>): TxBody {
        const message = { messages: [], memo: "", timeoutHeight: "0", extensionOptions: [], nonCriticalExtensionOptions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxBody): TxBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.protobuf.Any messages */ 1:
                    message.messages.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string memo */ 2:
                    message.memo = reader.string();
                    break;
                case /* uint64 timeout_height */ 3:
                    message.timeoutHeight = reader.uint64().toString();
                    break;
                case /* repeated google.protobuf.Any extension_options */ 1023:
                    message.extensionOptions.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated google.protobuf.Any non_critical_extension_options */ 2047:
                    message.nonCriticalExtensionOptions.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.protobuf.Any messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            Any.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string memo = 2; */
        if (message.memo !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.memo);
        /* uint64 timeout_height = 3; */
        if (message.timeoutHeight !== "0")
            writer.tag(3, WireType.Varint).uint64(message.timeoutHeight);
        /* repeated google.protobuf.Any extension_options = 1023; */
        for (let i = 0; i < message.extensionOptions.length; i++)
            Any.internalBinaryWrite(message.extensionOptions[i], writer.tag(1023, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.protobuf.Any non_critical_extension_options = 2047; */
        for (let i = 0; i < message.nonCriticalExtensionOptions.length; i++)
            Any.internalBinaryWrite(message.nonCriticalExtensionOptions[i], writer.tag(2047, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.TxBody
 */
export const TxBody = new TxBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthInfo$Type extends MessageType<AuthInfo> {
    constructor() {
        super("cosmos.tx.v1beta1.AuthInfo", [
            { no: 1, name: "signer_infos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SignerInfo },
            { no: 2, name: "fee", kind: "message", T: () => Fee }
        ]);
    }
    create(value?: PartialMessage<AuthInfo>): AuthInfo {
        const message = { signerInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthInfo): AuthInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.tx.v1beta1.SignerInfo signer_infos */ 1:
                    message.signerInfos.push(SignerInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* cosmos.tx.v1beta1.Fee fee */ 2:
                    message.fee = Fee.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.tx.v1beta1.SignerInfo signer_infos = 1; */
        for (let i = 0; i < message.signerInfos.length; i++)
            SignerInfo.internalBinaryWrite(message.signerInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.tx.v1beta1.Fee fee = 2; */
        if (message.fee)
            Fee.internalBinaryWrite(message.fee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.AuthInfo
 */
export const AuthInfo = new AuthInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignerInfo$Type extends MessageType<SignerInfo> {
    constructor() {
        super("cosmos.tx.v1beta1.SignerInfo", [
            { no: 1, name: "public_key", kind: "message", T: () => Any },
            { no: 2, name: "mode_info", kind: "message", T: () => ModeInfo },
            { no: 3, name: "sequence", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<SignerInfo>): SignerInfo {
        const message = { sequence: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignerInfo): SignerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any public_key */ 1:
                    message.publicKey = Any.internalBinaryRead(reader, reader.uint32(), options, message.publicKey);
                    break;
                case /* cosmos.tx.v1beta1.ModeInfo mode_info */ 2:
                    message.modeInfo = ModeInfo.internalBinaryRead(reader, reader.uint32(), options, message.modeInfo);
                    break;
                case /* uint64 sequence */ 3:
                    message.sequence = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any public_key = 1; */
        if (message.publicKey)
            Any.internalBinaryWrite(message.publicKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.tx.v1beta1.ModeInfo mode_info = 2; */
        if (message.modeInfo)
            ModeInfo.internalBinaryWrite(message.modeInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 sequence = 3; */
        if (message.sequence !== "0")
            writer.tag(3, WireType.Varint).uint64(message.sequence);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.SignerInfo
 */
export const SignerInfo = new SignerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModeInfo$Type extends MessageType<ModeInfo> {
    constructor() {
        super("cosmos.tx.v1beta1.ModeInfo", [
            { no: 1, name: "single", kind: "message", oneof: "sum", T: () => ModeInfo_Single },
            { no: 2, name: "multi", kind: "message", oneof: "sum", T: () => ModeInfo_Multi }
        ]);
    }
    create(value?: PartialMessage<ModeInfo>): ModeInfo {
        const message = { sum: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModeInfo): ModeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.tx.v1beta1.ModeInfo.Single single */ 1:
                    message.sum = {
                        oneofKind: "single",
                        single: ModeInfo_Single.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).single)
                    };
                    break;
                case /* cosmos.tx.v1beta1.ModeInfo.Multi multi */ 2:
                    message.sum = {
                        oneofKind: "multi",
                        multi: ModeInfo_Multi.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).multi)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.tx.v1beta1.ModeInfo.Single single = 1; */
        if (message.sum.oneofKind === "single")
            ModeInfo_Single.internalBinaryWrite(message.sum.single, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.tx.v1beta1.ModeInfo.Multi multi = 2; */
        if (message.sum.oneofKind === "multi")
            ModeInfo_Multi.internalBinaryWrite(message.sum.multi, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.ModeInfo
 */
export const ModeInfo = new ModeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModeInfo_Single$Type extends MessageType<ModeInfo_Single> {
    constructor() {
        super("cosmos.tx.v1beta1.ModeInfo.Single", [
            { no: 1, name: "mode", kind: "enum", T: () => ["cosmos.tx.signing.v1beta1.SignMode", SignMode, "SIGN_MODE_"] }
        ]);
    }
    create(value?: PartialMessage<ModeInfo_Single>): ModeInfo_Single {
        const message = { mode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModeInfo_Single>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModeInfo_Single): ModeInfo_Single {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.tx.signing.v1beta1.SignMode mode */ 1:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModeInfo_Single, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.tx.signing.v1beta1.SignMode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.ModeInfo.Single
 */
export const ModeInfo_Single = new ModeInfo_Single$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModeInfo_Multi$Type extends MessageType<ModeInfo_Multi> {
    constructor() {
        super("cosmos.tx.v1beta1.ModeInfo.Multi", [
            { no: 1, name: "bitarray", kind: "message", T: () => CompactBitArray },
            { no: 2, name: "mode_infos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ModeInfo }
        ]);
    }
    create(value?: PartialMessage<ModeInfo_Multi>): ModeInfo_Multi {
        const message = { modeInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModeInfo_Multi>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModeInfo_Multi): ModeInfo_Multi {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.crypto.multisig.v1beta1.CompactBitArray bitarray */ 1:
                    message.bitarray = CompactBitArray.internalBinaryRead(reader, reader.uint32(), options, message.bitarray);
                    break;
                case /* repeated cosmos.tx.v1beta1.ModeInfo mode_infos */ 2:
                    message.modeInfos.push(ModeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModeInfo_Multi, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.crypto.multisig.v1beta1.CompactBitArray bitarray = 1; */
        if (message.bitarray)
            CompactBitArray.internalBinaryWrite(message.bitarray, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated cosmos.tx.v1beta1.ModeInfo mode_infos = 2; */
        for (let i = 0; i < message.modeInfos.length; i++)
            ModeInfo.internalBinaryWrite(message.modeInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.ModeInfo.Multi
 */
export const ModeInfo_Multi = new ModeInfo_Multi$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fee$Type extends MessageType<Fee> {
    constructor() {
        super("cosmos.tx.v1beta1.Fee", [
            { no: 1, name: "amount", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coin, options: { "gogoproto.nullable": false, "gogoproto.castrepeated": "github.com/cosmos/cosmos-sdk/types.Coins" } },
            { no: 2, name: "gas_limit", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "payer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "granter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Fee>): Fee {
        const message = { amount: [], gasLimit: "0", payer: "", granter: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Fee>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Fee): Fee {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.v1beta1.Coin amount */ 1:
                    message.amount.push(Coin.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 gas_limit */ 2:
                    message.gasLimit = reader.uint64().toString();
                    break;
                case /* string payer */ 3:
                    message.payer = reader.string();
                    break;
                case /* string granter */ 4:
                    message.granter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Fee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.v1beta1.Coin amount = 1; */
        for (let i = 0; i < message.amount.length; i++)
            Coin.internalBinaryWrite(message.amount[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 gas_limit = 2; */
        if (message.gasLimit !== "0")
            writer.tag(2, WireType.Varint).uint64(message.gasLimit);
        /* string payer = 3; */
        if (message.payer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.payer);
        /* string granter = 4; */
        if (message.granter !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.granter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.tx.v1beta1.Fee
 */
export const Fee = new Fee$Type();
