// @generated by protobuf-ts 2.6.0 with parameter long_type_string
// @generated from protobuf file "cosmos/base/reflection/v2alpha1/reflection.proto" (package "cosmos.base.reflection.v2alpha1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * AppDescriptor describes a cosmos-sdk based application
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.AppDescriptor
 */
export interface AppDescriptor {
    /**
     * AuthnDescriptor provides information on how to authenticate transactions on the application
     * NOTE: experimental and subject to change in future releases.
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1;
     */
    authn?: AuthnDescriptor;
    /**
     * chain provides the chain descriptor
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 2;
     */
    chain?: ChainDescriptor;
    /**
     * codec provides metadata information regarding codec related types
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 3;
     */
    codec?: CodecDescriptor;
    /**
     * configuration provides metadata information regarding the sdk.Config type
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.ConfigurationDescriptor configuration = 4;
     */
    configuration?: ConfigurationDescriptor;
    /**
     * query_services provides metadata information regarding the available queriable endpoints
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.QueryServicesDescriptor query_services = 5;
     */
    queryServices?: QueryServicesDescriptor;
    /**
     * tx provides metadata information regarding how to send transactions to the given application
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.TxDescriptor tx = 6;
     */
    tx?: TxDescriptor;
}
/**
 * TxDescriptor describes the accepted transaction type
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.TxDescriptor
 */
export interface TxDescriptor {
    /**
     * fullname is the protobuf fullname of the raw transaction type (for instance the tx.Tx type)
     * it is not meant to support polymorphism of transaction types, it is supposed to be used by
     * reflection clients to understand if they can handle a specific transaction type in an application.
     *
     * @generated from protobuf field: string fullname = 1;
     */
    fullname: string;
    /**
     * msgs lists the accepted application messages (sdk.Msg)
     *
     * @generated from protobuf field: repeated cosmos.base.reflection.v2alpha1.MsgDescriptor msgs = 2;
     */
    msgs: MsgDescriptor[];
}
/**
 * AuthnDescriptor provides information on how to sign transactions without relying
 * on the online RPCs GetTxMetadata and CombineUnsignedTxAndSignatures
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.AuthnDescriptor
 */
export interface AuthnDescriptor {
    /**
     * sign_modes defines the supported signature algorithm
     *
     * @generated from protobuf field: repeated cosmos.base.reflection.v2alpha1.SigningModeDescriptor sign_modes = 1;
     */
    signModes: SigningModeDescriptor[];
}
/**
 * SigningModeDescriptor provides information on a signing flow of the application
 * NOTE(fdymylja): here we could go as far as providing an entire flow on how
 * to sign a message given a SigningModeDescriptor, but it's better to think about
 * this another time
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.SigningModeDescriptor
 */
export interface SigningModeDescriptor {
    /**
     * name defines the unique name of the signing mode
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * number is the unique int32 identifier for the sign_mode enum
     *
     * @generated from protobuf field: int32 number = 2;
     */
    number: number;
    /**
     * authn_info_provider_method_fullname defines the fullname of the method to call to get
     * the metadata required to authenticate using the provided sign_modes
     *
     * @generated from protobuf field: string authn_info_provider_method_fullname = 3;
     */
    authnInfoProviderMethodFullname: string;
}
/**
 * ChainDescriptor describes chain information of the application
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.ChainDescriptor
 */
export interface ChainDescriptor {
    /**
     * id is the chain id
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * CodecDescriptor describes the registered interfaces and provides metadata information on the types
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.CodecDescriptor
 */
export interface CodecDescriptor {
    /**
     * interfaces is a list of the registerted interfaces descriptors
     *
     * @generated from protobuf field: repeated cosmos.base.reflection.v2alpha1.InterfaceDescriptor interfaces = 1;
     */
    interfaces: InterfaceDescriptor[];
}
/**
 * InterfaceDescriptor describes the implementation of an interface
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.InterfaceDescriptor
 */
export interface InterfaceDescriptor {
    /**
     * fullname is the name of the interface
     *
     * @generated from protobuf field: string fullname = 1;
     */
    fullname: string;
    /**
     * interface_accepting_messages contains information regarding the proto messages which contain the interface as
     * google.protobuf.Any field
     *
     * @generated from protobuf field: repeated cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor interface_accepting_messages = 2;
     */
    interfaceAcceptingMessages: InterfaceAcceptingMessageDescriptor[];
    /**
     * interface_implementers is a list of the descriptors of the interface implementers
     *
     * @generated from protobuf field: repeated cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor interface_implementers = 3;
     */
    interfaceImplementers: InterfaceImplementerDescriptor[];
}
/**
 * InterfaceImplementerDescriptor describes an interface implementer
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor
 */
export interface InterfaceImplementerDescriptor {
    /**
     * fullname is the protobuf queryable name of the interface implementer
     *
     * @generated from protobuf field: string fullname = 1;
     */
    fullname: string;
    /**
     * type_url defines the type URL used when marshalling the type as any
     * this is required so we can provide type safe google.protobuf.Any marshalling and
     * unmarshalling, making sure that we don't accept just 'any' type
     * in our interface fields
     *
     * @generated from protobuf field: string type_url = 2;
     */
    typeUrl: string;
}
/**
 * InterfaceAcceptingMessageDescriptor describes a protobuf message which contains
 * an interface represented as a google.protobuf.Any
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor
 */
export interface InterfaceAcceptingMessageDescriptor {
    /**
     * fullname is the protobuf fullname of the type containing the interface
     *
     * @generated from protobuf field: string fullname = 1;
     */
    fullname: string;
    /**
     * field_descriptor_names is a list of the protobuf name (not fullname) of the field
     * which contains the interface as google.protobuf.Any (the interface is the same, but
     * it can be in multiple fields of the same proto message)
     *
     * @generated from protobuf field: repeated string field_descriptor_names = 2;
     */
    fieldDescriptorNames: string[];
}
/**
 * ConfigurationDescriptor contains metadata information on the sdk.Config
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.ConfigurationDescriptor
 */
export interface ConfigurationDescriptor {
    /**
     * bech32_account_address_prefix is the account address prefix
     *
     * @generated from protobuf field: string bech32_account_address_prefix = 1;
     */
    bech32AccountAddressPrefix: string;
}
/**
 * MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.MsgDescriptor
 */
export interface MsgDescriptor {
    /**
     * msg_type_url contains the TypeURL of a sdk.Msg.
     *
     * @generated from protobuf field: string msg_type_url = 1;
     */
    msgTypeUrl: string;
}
/**
 * GetAuthnDescriptorRequest is the request used for the GetAuthnDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest
 */
export interface GetAuthnDescriptorRequest {
}
/**
 * GetAuthnDescriptorResponse is the response returned by the GetAuthnDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse
 */
export interface GetAuthnDescriptorResponse {
    /**
     * authn describes how to authenticate to the application when sending transactions
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1;
     */
    authn?: AuthnDescriptor;
}
/**
 * GetChainDescriptorRequest is the request used for the GetChainDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest
 */
export interface GetChainDescriptorRequest {
}
/**
 * GetChainDescriptorResponse is the response returned by the GetChainDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse
 */
export interface GetChainDescriptorResponse {
    /**
     * chain describes application chain information
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 1;
     */
    chain?: ChainDescriptor;
}
/**
 * GetCodecDescriptorRequest is the request used for the GetCodecDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest
 */
export interface GetCodecDescriptorRequest {
}
/**
 * GetCodecDescriptorResponse is the response returned by the GetCodecDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse
 */
export interface GetCodecDescriptorResponse {
    /**
     * codec describes the application codec such as registered interfaces and implementations
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 1;
     */
    codec?: CodecDescriptor;
}
/**
 * GetConfigurationDescriptorRequest is the request used for the GetConfigurationDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest
 */
export interface GetConfigurationDescriptorRequest {
}
/**
 * GetConfigurationDescriptorResponse is the response returned by the GetConfigurationDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse
 */
export interface GetConfigurationDescriptorResponse {
    /**
     * config describes the application's sdk.Config
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.ConfigurationDescriptor config = 1;
     */
    config?: ConfigurationDescriptor;
}
/**
 * GetQueryServicesDescriptorRequest is the request used for the GetQueryServicesDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest
 */
export interface GetQueryServicesDescriptorRequest {
}
/**
 * GetQueryServicesDescriptorResponse is the response returned by the GetQueryServicesDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse
 */
export interface GetQueryServicesDescriptorResponse {
    /**
     * queries provides information on the available queryable services
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.QueryServicesDescriptor queries = 1;
     */
    queries?: QueryServicesDescriptor;
}
/**
 * GetTxDescriptorRequest is the request used for the GetTxDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest
 */
export interface GetTxDescriptorRequest {
}
/**
 * GetTxDescriptorResponse is the response returned by the GetTxDescriptor RPC
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse
 */
export interface GetTxDescriptorResponse {
    /**
     * tx provides information on msgs that can be forwarded to the application
     * alongside the accepted transaction protobuf type
     *
     * @generated from protobuf field: cosmos.base.reflection.v2alpha1.TxDescriptor tx = 1;
     */
    tx?: TxDescriptor;
}
/**
 * QueryServicesDescriptor contains the list of cosmos-sdk queriable services
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.QueryServicesDescriptor
 */
export interface QueryServicesDescriptor {
    /**
     * query_services is a list of cosmos-sdk QueryServiceDescriptor
     *
     * @generated from protobuf field: repeated cosmos.base.reflection.v2alpha1.QueryServiceDescriptor query_services = 1;
     */
    queryServices: QueryServiceDescriptor[];
}
/**
 * QueryServiceDescriptor describes a cosmos-sdk queryable service
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.QueryServiceDescriptor
 */
export interface QueryServiceDescriptor {
    /**
     * fullname is the protobuf fullname of the service descriptor
     *
     * @generated from protobuf field: string fullname = 1;
     */
    fullname: string;
    /**
     * is_module describes if this service is actually exposed by an application's module
     *
     * @generated from protobuf field: bool is_module = 2;
     */
    isModule: boolean;
    /**
     * methods provides a list of query service methods
     *
     * @generated from protobuf field: repeated cosmos.base.reflection.v2alpha1.QueryMethodDescriptor methods = 3;
     */
    methods: QueryMethodDescriptor[];
}
/**
 * QueryMethodDescriptor describes a queryable method of a query service
 * no other info is provided beside method name and tendermint queryable path
 * because it would be redundant with the grpc reflection service
 *
 * @generated from protobuf message cosmos.base.reflection.v2alpha1.QueryMethodDescriptor
 */
export interface QueryMethodDescriptor {
    /**
     * name is the protobuf name (not fullname) of the method
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * full_query_path is the path that can be used to query
     * this method via tendermint abci.Query
     *
     * @generated from protobuf field: string full_query_path = 2;
     */
    fullQueryPath: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class AppDescriptor$Type extends MessageType<AppDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.AppDescriptor", [
            { no: 1, name: "authn", kind: "message", T: () => AuthnDescriptor },
            { no: 2, name: "chain", kind: "message", T: () => ChainDescriptor },
            { no: 3, name: "codec", kind: "message", T: () => CodecDescriptor },
            { no: 4, name: "configuration", kind: "message", T: () => ConfigurationDescriptor },
            { no: 5, name: "query_services", kind: "message", T: () => QueryServicesDescriptor },
            { no: 6, name: "tx", kind: "message", T: () => TxDescriptor }
        ]);
    }
    create(value?: PartialMessage<AppDescriptor>): AppDescriptor {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppDescriptor): AppDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.reflection.v2alpha1.AuthnDescriptor authn */ 1:
                    message.authn = AuthnDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.authn);
                    break;
                case /* cosmos.base.reflection.v2alpha1.ChainDescriptor chain */ 2:
                    message.chain = ChainDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.chain);
                    break;
                case /* cosmos.base.reflection.v2alpha1.CodecDescriptor codec */ 3:
                    message.codec = CodecDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.codec);
                    break;
                case /* cosmos.base.reflection.v2alpha1.ConfigurationDescriptor configuration */ 4:
                    message.configuration = ConfigurationDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                case /* cosmos.base.reflection.v2alpha1.QueryServicesDescriptor query_services */ 5:
                    message.queryServices = QueryServicesDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.queryServices);
                    break;
                case /* cosmos.base.reflection.v2alpha1.TxDescriptor tx */ 6:
                    message.tx = TxDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.tx);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1; */
        if (message.authn)
            AuthnDescriptor.internalBinaryWrite(message.authn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 2; */
        if (message.chain)
            ChainDescriptor.internalBinaryWrite(message.chain, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 3; */
        if (message.codec)
            CodecDescriptor.internalBinaryWrite(message.codec, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.reflection.v2alpha1.ConfigurationDescriptor configuration = 4; */
        if (message.configuration)
            ConfigurationDescriptor.internalBinaryWrite(message.configuration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.reflection.v2alpha1.QueryServicesDescriptor query_services = 5; */
        if (message.queryServices)
            QueryServicesDescriptor.internalBinaryWrite(message.queryServices, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* cosmos.base.reflection.v2alpha1.TxDescriptor tx = 6; */
        if (message.tx)
            TxDescriptor.internalBinaryWrite(message.tx, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.AppDescriptor
 */
export const AppDescriptor = new AppDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxDescriptor$Type extends MessageType<TxDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.TxDescriptor", [
            { no: 1, name: "fullname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "msgs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MsgDescriptor }
        ]);
    }
    create(value?: PartialMessage<TxDescriptor>): TxDescriptor {
        const message = { fullname: "", msgs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxDescriptor): TxDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fullname */ 1:
                    message.fullname = reader.string();
                    break;
                case /* repeated cosmos.base.reflection.v2alpha1.MsgDescriptor msgs */ 2:
                    message.msgs.push(MsgDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fullname = 1; */
        if (message.fullname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fullname);
        /* repeated cosmos.base.reflection.v2alpha1.MsgDescriptor msgs = 2; */
        for (let i = 0; i < message.msgs.length; i++)
            MsgDescriptor.internalBinaryWrite(message.msgs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.TxDescriptor
 */
export const TxDescriptor = new TxDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthnDescriptor$Type extends MessageType<AuthnDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.AuthnDescriptor", [
            { no: 1, name: "sign_modes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SigningModeDescriptor }
        ]);
    }
    create(value?: PartialMessage<AuthnDescriptor>): AuthnDescriptor {
        const message = { signModes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AuthnDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthnDescriptor): AuthnDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.reflection.v2alpha1.SigningModeDescriptor sign_modes */ 1:
                    message.signModes.push(SigningModeDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthnDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.reflection.v2alpha1.SigningModeDescriptor sign_modes = 1; */
        for (let i = 0; i < message.signModes.length; i++)
            SigningModeDescriptor.internalBinaryWrite(message.signModes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.AuthnDescriptor
 */
export const AuthnDescriptor = new AuthnDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SigningModeDescriptor$Type extends MessageType<SigningModeDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.SigningModeDescriptor", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "authn_info_provider_method_fullname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SigningModeDescriptor>): SigningModeDescriptor {
        const message = { name: "", number: 0, authnInfoProviderMethodFullname: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SigningModeDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SigningModeDescriptor): SigningModeDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 number */ 2:
                    message.number = reader.int32();
                    break;
                case /* string authn_info_provider_method_fullname */ 3:
                    message.authnInfoProviderMethodFullname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SigningModeDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 number = 2; */
        if (message.number !== 0)
            writer.tag(2, WireType.Varint).int32(message.number);
        /* string authn_info_provider_method_fullname = 3; */
        if (message.authnInfoProviderMethodFullname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.authnInfoProviderMethodFullname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.SigningModeDescriptor
 */
export const SigningModeDescriptor = new SigningModeDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChainDescriptor$Type extends MessageType<ChainDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.ChainDescriptor", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChainDescriptor>): ChainDescriptor {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChainDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChainDescriptor): ChainDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChainDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.ChainDescriptor
 */
export const ChainDescriptor = new ChainDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodecDescriptor$Type extends MessageType<CodecDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.CodecDescriptor", [
            { no: 1, name: "interfaces", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InterfaceDescriptor }
        ]);
    }
    create(value?: PartialMessage<CodecDescriptor>): CodecDescriptor {
        const message = { interfaces: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CodecDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodecDescriptor): CodecDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.reflection.v2alpha1.InterfaceDescriptor interfaces */ 1:
                    message.interfaces.push(InterfaceDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CodecDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.reflection.v2alpha1.InterfaceDescriptor interfaces = 1; */
        for (let i = 0; i < message.interfaces.length; i++)
            InterfaceDescriptor.internalBinaryWrite(message.interfaces[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.CodecDescriptor
 */
export const CodecDescriptor = new CodecDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterfaceDescriptor$Type extends MessageType<InterfaceDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.InterfaceDescriptor", [
            { no: 1, name: "fullname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "interface_accepting_messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InterfaceAcceptingMessageDescriptor },
            { no: 3, name: "interface_implementers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InterfaceImplementerDescriptor }
        ]);
    }
    create(value?: PartialMessage<InterfaceDescriptor>): InterfaceDescriptor {
        const message = { fullname: "", interfaceAcceptingMessages: [], interfaceImplementers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InterfaceDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterfaceDescriptor): InterfaceDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fullname */ 1:
                    message.fullname = reader.string();
                    break;
                case /* repeated cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor interface_accepting_messages */ 2:
                    message.interfaceAcceptingMessages.push(InterfaceAcceptingMessageDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor interface_implementers */ 3:
                    message.interfaceImplementers.push(InterfaceImplementerDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterfaceDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fullname = 1; */
        if (message.fullname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fullname);
        /* repeated cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor interface_accepting_messages = 2; */
        for (let i = 0; i < message.interfaceAcceptingMessages.length; i++)
            InterfaceAcceptingMessageDescriptor.internalBinaryWrite(message.interfaceAcceptingMessages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor interface_implementers = 3; */
        for (let i = 0; i < message.interfaceImplementers.length; i++)
            InterfaceImplementerDescriptor.internalBinaryWrite(message.interfaceImplementers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.InterfaceDescriptor
 */
export const InterfaceDescriptor = new InterfaceDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterfaceImplementerDescriptor$Type extends MessageType<InterfaceImplementerDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor", [
            { no: 1, name: "fullname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InterfaceImplementerDescriptor>): InterfaceImplementerDescriptor {
        const message = { fullname: "", typeUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InterfaceImplementerDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterfaceImplementerDescriptor): InterfaceImplementerDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fullname */ 1:
                    message.fullname = reader.string();
                    break;
                case /* string type_url */ 2:
                    message.typeUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterfaceImplementerDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fullname = 1; */
        if (message.fullname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fullname);
        /* string type_url = 2; */
        if (message.typeUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.typeUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor
 */
export const InterfaceImplementerDescriptor = new InterfaceImplementerDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InterfaceAcceptingMessageDescriptor$Type extends MessageType<InterfaceAcceptingMessageDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor", [
            { no: 1, name: "fullname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "field_descriptor_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InterfaceAcceptingMessageDescriptor>): InterfaceAcceptingMessageDescriptor {
        const message = { fullname: "", fieldDescriptorNames: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InterfaceAcceptingMessageDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InterfaceAcceptingMessageDescriptor): InterfaceAcceptingMessageDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fullname */ 1:
                    message.fullname = reader.string();
                    break;
                case /* repeated string field_descriptor_names */ 2:
                    message.fieldDescriptorNames.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InterfaceAcceptingMessageDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fullname = 1; */
        if (message.fullname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fullname);
        /* repeated string field_descriptor_names = 2; */
        for (let i = 0; i < message.fieldDescriptorNames.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.fieldDescriptorNames[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor
 */
export const InterfaceAcceptingMessageDescriptor = new InterfaceAcceptingMessageDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigurationDescriptor$Type extends MessageType<ConfigurationDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.ConfigurationDescriptor", [
            { no: 1, name: "bech32_account_address_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigurationDescriptor>): ConfigurationDescriptor {
        const message = { bech32AccountAddressPrefix: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ConfigurationDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigurationDescriptor): ConfigurationDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string bech32_account_address_prefix */ 1:
                    message.bech32AccountAddressPrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigurationDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string bech32_account_address_prefix = 1; */
        if (message.bech32AccountAddressPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.bech32AccountAddressPrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.ConfigurationDescriptor
 */
export const ConfigurationDescriptor = new ConfigurationDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgDescriptor$Type extends MessageType<MsgDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.MsgDescriptor", [
            { no: 1, name: "msg_type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MsgDescriptor>): MsgDescriptor {
        const message = { msgTypeUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MsgDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgDescriptor): MsgDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msg_type_url */ 1:
                    message.msgTypeUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msg_type_url = 1; */
        if (message.msgTypeUrl !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msgTypeUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.MsgDescriptor
 */
export const MsgDescriptor = new MsgDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthnDescriptorRequest$Type extends MessageType<GetAuthnDescriptorRequest> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest", []);
    }
    create(value?: PartialMessage<GetAuthnDescriptorRequest>): GetAuthnDescriptorRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAuthnDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthnDescriptorRequest): GetAuthnDescriptorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAuthnDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest
 */
export const GetAuthnDescriptorRequest = new GetAuthnDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthnDescriptorResponse$Type extends MessageType<GetAuthnDescriptorResponse> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse", [
            { no: 1, name: "authn", kind: "message", T: () => AuthnDescriptor }
        ]);
    }
    create(value?: PartialMessage<GetAuthnDescriptorResponse>): GetAuthnDescriptorResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAuthnDescriptorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAuthnDescriptorResponse): GetAuthnDescriptorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.reflection.v2alpha1.AuthnDescriptor authn */ 1:
                    message.authn = AuthnDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.authn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAuthnDescriptorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1; */
        if (message.authn)
            AuthnDescriptor.internalBinaryWrite(message.authn, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse
 */
export const GetAuthnDescriptorResponse = new GetAuthnDescriptorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChainDescriptorRequest$Type extends MessageType<GetChainDescriptorRequest> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest", []);
    }
    create(value?: PartialMessage<GetChainDescriptorRequest>): GetChainDescriptorRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChainDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChainDescriptorRequest): GetChainDescriptorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetChainDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest
 */
export const GetChainDescriptorRequest = new GetChainDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChainDescriptorResponse$Type extends MessageType<GetChainDescriptorResponse> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse", [
            { no: 1, name: "chain", kind: "message", T: () => ChainDescriptor }
        ]);
    }
    create(value?: PartialMessage<GetChainDescriptorResponse>): GetChainDescriptorResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChainDescriptorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChainDescriptorResponse): GetChainDescriptorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.reflection.v2alpha1.ChainDescriptor chain */ 1:
                    message.chain = ChainDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.chain);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChainDescriptorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 1; */
        if (message.chain)
            ChainDescriptor.internalBinaryWrite(message.chain, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse
 */
export const GetChainDescriptorResponse = new GetChainDescriptorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCodecDescriptorRequest$Type extends MessageType<GetCodecDescriptorRequest> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest", []);
    }
    create(value?: PartialMessage<GetCodecDescriptorRequest>): GetCodecDescriptorRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCodecDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCodecDescriptorRequest): GetCodecDescriptorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetCodecDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest
 */
export const GetCodecDescriptorRequest = new GetCodecDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCodecDescriptorResponse$Type extends MessageType<GetCodecDescriptorResponse> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse", [
            { no: 1, name: "codec", kind: "message", T: () => CodecDescriptor }
        ]);
    }
    create(value?: PartialMessage<GetCodecDescriptorResponse>): GetCodecDescriptorResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCodecDescriptorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCodecDescriptorResponse): GetCodecDescriptorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.reflection.v2alpha1.CodecDescriptor codec */ 1:
                    message.codec = CodecDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.codec);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCodecDescriptorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 1; */
        if (message.codec)
            CodecDescriptor.internalBinaryWrite(message.codec, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse
 */
export const GetCodecDescriptorResponse = new GetCodecDescriptorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigurationDescriptorRequest$Type extends MessageType<GetConfigurationDescriptorRequest> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest", []);
    }
    create(value?: PartialMessage<GetConfigurationDescriptorRequest>): GetConfigurationDescriptorRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConfigurationDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigurationDescriptorRequest): GetConfigurationDescriptorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetConfigurationDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest
 */
export const GetConfigurationDescriptorRequest = new GetConfigurationDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigurationDescriptorResponse$Type extends MessageType<GetConfigurationDescriptorResponse> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse", [
            { no: 1, name: "config", kind: "message", T: () => ConfigurationDescriptor }
        ]);
    }
    create(value?: PartialMessage<GetConfigurationDescriptorResponse>): GetConfigurationDescriptorResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConfigurationDescriptorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigurationDescriptorResponse): GetConfigurationDescriptorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.reflection.v2alpha1.ConfigurationDescriptor config */ 1:
                    message.config = ConfigurationDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConfigurationDescriptorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.reflection.v2alpha1.ConfigurationDescriptor config = 1; */
        if (message.config)
            ConfigurationDescriptor.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse
 */
export const GetConfigurationDescriptorResponse = new GetConfigurationDescriptorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetQueryServicesDescriptorRequest$Type extends MessageType<GetQueryServicesDescriptorRequest> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest", []);
    }
    create(value?: PartialMessage<GetQueryServicesDescriptorRequest>): GetQueryServicesDescriptorRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetQueryServicesDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetQueryServicesDescriptorRequest): GetQueryServicesDescriptorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetQueryServicesDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest
 */
export const GetQueryServicesDescriptorRequest = new GetQueryServicesDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetQueryServicesDescriptorResponse$Type extends MessageType<GetQueryServicesDescriptorResponse> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse", [
            { no: 1, name: "queries", kind: "message", T: () => QueryServicesDescriptor }
        ]);
    }
    create(value?: PartialMessage<GetQueryServicesDescriptorResponse>): GetQueryServicesDescriptorResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetQueryServicesDescriptorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetQueryServicesDescriptorResponse): GetQueryServicesDescriptorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.reflection.v2alpha1.QueryServicesDescriptor queries */ 1:
                    message.queries = QueryServicesDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.queries);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetQueryServicesDescriptorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.reflection.v2alpha1.QueryServicesDescriptor queries = 1; */
        if (message.queries)
            QueryServicesDescriptor.internalBinaryWrite(message.queries, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse
 */
export const GetQueryServicesDescriptorResponse = new GetQueryServicesDescriptorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxDescriptorRequest$Type extends MessageType<GetTxDescriptorRequest> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest", []);
    }
    create(value?: PartialMessage<GetTxDescriptorRequest>): GetTxDescriptorRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTxDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxDescriptorRequest): GetTxDescriptorRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetTxDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest
 */
export const GetTxDescriptorRequest = new GetTxDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTxDescriptorResponse$Type extends MessageType<GetTxDescriptorResponse> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse", [
            { no: 1, name: "tx", kind: "message", T: () => TxDescriptor }
        ]);
    }
    create(value?: PartialMessage<GetTxDescriptorResponse>): GetTxDescriptorResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetTxDescriptorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTxDescriptorResponse): GetTxDescriptorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cosmos.base.reflection.v2alpha1.TxDescriptor tx */ 1:
                    message.tx = TxDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.tx);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTxDescriptorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cosmos.base.reflection.v2alpha1.TxDescriptor tx = 1; */
        if (message.tx)
            TxDescriptor.internalBinaryWrite(message.tx, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse
 */
export const GetTxDescriptorResponse = new GetTxDescriptorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryServicesDescriptor$Type extends MessageType<QueryServicesDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.QueryServicesDescriptor", [
            { no: 1, name: "query_services", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryServiceDescriptor }
        ]);
    }
    create(value?: PartialMessage<QueryServicesDescriptor>): QueryServicesDescriptor {
        const message = { queryServices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryServicesDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryServicesDescriptor): QueryServicesDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated cosmos.base.reflection.v2alpha1.QueryServiceDescriptor query_services */ 1:
                    message.queryServices.push(QueryServiceDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryServicesDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated cosmos.base.reflection.v2alpha1.QueryServiceDescriptor query_services = 1; */
        for (let i = 0; i < message.queryServices.length; i++)
            QueryServiceDescriptor.internalBinaryWrite(message.queryServices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.QueryServicesDescriptor
 */
export const QueryServicesDescriptor = new QueryServicesDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryServiceDescriptor$Type extends MessageType<QueryServiceDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.QueryServiceDescriptor", [
            { no: 1, name: "fullname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "is_module", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "methods", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryMethodDescriptor }
        ]);
    }
    create(value?: PartialMessage<QueryServiceDescriptor>): QueryServiceDescriptor {
        const message = { fullname: "", isModule: false, methods: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryServiceDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryServiceDescriptor): QueryServiceDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string fullname */ 1:
                    message.fullname = reader.string();
                    break;
                case /* bool is_module */ 2:
                    message.isModule = reader.bool();
                    break;
                case /* repeated cosmos.base.reflection.v2alpha1.QueryMethodDescriptor methods */ 3:
                    message.methods.push(QueryMethodDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryServiceDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string fullname = 1; */
        if (message.fullname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.fullname);
        /* bool is_module = 2; */
        if (message.isModule !== false)
            writer.tag(2, WireType.Varint).bool(message.isModule);
        /* repeated cosmos.base.reflection.v2alpha1.QueryMethodDescriptor methods = 3; */
        for (let i = 0; i < message.methods.length; i++)
            QueryMethodDescriptor.internalBinaryWrite(message.methods[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.QueryServiceDescriptor
 */
export const QueryServiceDescriptor = new QueryServiceDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryMethodDescriptor$Type extends MessageType<QueryMethodDescriptor> {
    constructor() {
        super("cosmos.base.reflection.v2alpha1.QueryMethodDescriptor", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "full_query_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryMethodDescriptor>): QueryMethodDescriptor {
        const message = { name: "", fullQueryPath: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryMethodDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryMethodDescriptor): QueryMethodDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string full_query_path */ 2:
                    message.fullQueryPath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryMethodDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string full_query_path = 2; */
        if (message.fullQueryPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.fullQueryPath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cosmos.base.reflection.v2alpha1.QueryMethodDescriptor
 */
export const QueryMethodDescriptor = new QueryMethodDescriptor$Type();
/**
 * @generated ServiceType for protobuf service cosmos.base.reflection.v2alpha1.ReflectionService
 */
export const ReflectionService = new ServiceType("cosmos.base.reflection.v2alpha1.ReflectionService", [
    { name: "GetAuthnDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/authn" } }, I: GetAuthnDescriptorRequest, O: GetAuthnDescriptorResponse },
    { name: "GetChainDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/chain" } }, I: GetChainDescriptorRequest, O: GetChainDescriptorResponse },
    { name: "GetCodecDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/codec" } }, I: GetCodecDescriptorRequest, O: GetCodecDescriptorResponse },
    { name: "GetConfigurationDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/configuration" } }, I: GetConfigurationDescriptorRequest, O: GetConfigurationDescriptorResponse },
    { name: "GetQueryServicesDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/query_services" } }, I: GetQueryServicesDescriptorRequest, O: GetQueryServicesDescriptorResponse },
    { name: "GetTxDescriptor", options: { "google.api.http": { get: "/cosmos/base/reflection/v1beta1/app_descriptor/tx_descriptor" } }, I: GetTxDescriptorRequest, O: GetTxDescriptorResponse }
]);
